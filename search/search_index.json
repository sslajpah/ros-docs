{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ROS intro Following pages serve as a help while dealing with ROS projects.","title":"ROS intro"},{"location":"#ros-intro","text":"Following pages serve as a help while dealing with ROS projects.","title":"ROS intro"},{"location":"additional/","text":"Navodila za namestitev Ubuntu 18.04 Server + ROS Melodic na RaspberryPi 4 Headless uporaba RPI Povezava preko SSH SSH poveza z Visual Studio Code Namestitev Ubuntu 18.04 Server Uporabi Disc Management in formatiraj 16 Gb SD kartico Snemi ubuntu-18.04.5-preinstalled-server-arm64+raspi4.img.xz Extrahiraj sliko (7zip) Sledi navodilom za namestitev . Na RaspberryPi priklopi ekran, mi\u0161ko in tipkovnico, se prijavi v ubuntu sistem username : ubuntu password : ubuntu in spremeni geslo. Sledi navodilom za postavitev mre\u017ee in SSH . Spremeni geslo: sudo passwd ubuntu Namestitev ROS Pove\u017ei se preko SSH Sledi navodilom , namesti\u0161 ROS-Base (ker je Ubuntu server, nima smisla name\u0161\u010dati grafi\u010dna orodja) Desni mi\u0161kin klik je \u201cpaste\u201d v cmd. Ko namestis, naredi catkin_ws cd mkdir catkin_ws cd catkin_ws mkdir src cd .. catkin_make Dodaj \u0161e source za ROS spremenljivke echo \"source ~/catkin_ws/devel/setup.bash\" >> ~/.bashrc source ~/.bashrc Nastavitev stati\u010dnega IP Vir S spodnjim ukazom dobi seznam vseh mre\u017enih naprav: ifconfig Poi\u0161\u010di ustrezno mre\u017eno kartico (po navadi je eth0 ). Postavi se v /etc/netplan cd /etc/netplan in odpri 01-netcfg.yaml (\u010de je ni, preveri z ll ) sudo nano /etc/netplan/01-netcfg.yaml Dodaj spodnjo kodo, kjer nastavi\u0161 ustrezne mre\u017ene nastavitve. Pozorni bodite na ustrezne zamike (uporabite presledke ne tabulator). 1 2 3 4 5 6 7 8 9 10 network : ethernets : eth0 : dhcp4 : false addresses : - 192.168.65.60 / 24 gateway4 : 192.168.65.254 nameservers : addresses : [ 192.168.65.14 , 193.2.1.66 ] version : 2 Na koncu ponovno za\u017eeni netplan sudo netplan apply ter preveri, \u010de so nastavitve pravilne z ifconfig Povezava s SSH V Win CMD se pove\u017ee\u0161 s: ssh RPI_uporabnisko_ime@RPI_IP Povezava z VS Code Sledi navodilom Pozor! Potrebuje\u0161 delujo\u010do mre\u017eno povezavo! GPIO na RaspberryPi rpi.gpio Namestitev: sudo apt-get update sudo apt-get install python-rpi.gpio Dodaj trenutnega uporabnika v skupino dialout : sudo adduser $USER dialout in ponovno za\u017eeni RPi. Uporaba: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import rospy import RPi.GPIO as GPIO # button GPIO # button 1 - GPIO 11 # button 2 - GPIO 12 # LED GPIO # Green 1 - GPIO 2 # Green 2 - GPIO 3 # Yellow 1 - GPIO 4 # Yellow 2 - GPIO 5 # Red 1 - GPIO 6 # Red 2 - GPIO 7 def resetLed (): # nastavi in resetiraj vse LED for ii in range ( 2 , 8 ): # nastavi IO kot izhode GPIO . setup ( ii , GPIO . OUT ) # postavi izhode na nizek nivo GPIO . output ( ii , False ) if __name__ == '__main__' : # node init rospy . init_node ( 'test_gpio_rpi' ) # set GPIO as BCM GPIO . setmode ( GPIO . BCM ) # reset LED resetLed () # set button1 as input GPIO . setup ( 11 , GPIO . IN ) # set loop to 10 Hz rate = rospy . Rate ( 10 ) while not rospy . is_shutdown (): # read GPIO gpio_state = GPIO . input ( 11 ) \"\"\" interrupt definition GPIO.add_event_detect(gpio_num, detected_edge, callback, bouncetime) GPIO.add_event_detect(BUTTON_GPIO, GPIO.RISING, callback=button_callback, bouncetime=500) \"\"\" GPIO . output ( 2 , False ) if gpio_state : GPIO . output ( 2 , True ) rate . sleep () # clean GPIO settings after stop GPIO . cleanup () SICK NanoScan3 Manual - wiki 1651 measurements angle resolution: 0.002909 rad scan angle: 275\u00b0 Install ROS support sudo apt-get install ros-melodic-sick-safetyscanners Run the driver roslaunch sick_safetyscanners sick_safetyscanners.launch sensor_ip:=<sensor ip> host_ip:=<host ip> Published topics Topic: /sick_safetyscanners/scan Message type: sensor_msgs/LaserScan Linux ukazi Uporabni ukazi v Linux okolju Dostop to root direktorija: cd / Premik v prej\u0161njo mapo: cd .. Premik v doma\u010do mapo: cd /home/$user$ cd ~ Izpis trenutne poti: pwd Prika\u017ei vsebino mape: ls Prika\u017ei tudi skrito vsebino mape: ls -l Ustvari novo mapo my_folder : mkdir my_folder Izbri\u0161i prazno mapo my_folder : rmdir my_folder Izbri\u0161i mapo my_folder , ki ni prazna: rm -rf my_folder Spremeni pravice datoteke my_file v executable: chmod +x my_file Ustvari novo datoteko my_file.py touch my_file.py Odpri datoteko my_file.py v Visual Studio Code: code my_file.py Odpri datoteko my_file.py v konzolnem urejevalniku besedila nano : nano my_file.py","title":"ROS na RaspberryPi4"},{"location":"additional/#navodila-za-namestitev-ubuntu-1804-server-ros-melodic-na-raspberrypi-4","text":"Headless uporaba RPI Povezava preko SSH SSH poveza z Visual Studio Code","title":"Navodila za namestitev Ubuntu 18.04 Server + ROS Melodic na RaspberryPi 4"},{"location":"additional/#namestitev-ubuntu-1804-server","text":"Uporabi Disc Management in formatiraj 16 Gb SD kartico Snemi ubuntu-18.04.5-preinstalled-server-arm64+raspi4.img.xz Extrahiraj sliko (7zip) Sledi navodilom za namestitev . Na RaspberryPi priklopi ekran, mi\u0161ko in tipkovnico, se prijavi v ubuntu sistem username : ubuntu password : ubuntu in spremeni geslo. Sledi navodilom za postavitev mre\u017ee in SSH . Spremeni geslo: sudo passwd ubuntu","title":"Namestitev Ubuntu 18.04 Server"},{"location":"additional/#namestitev-ros","text":"Pove\u017ei se preko SSH Sledi navodilom , namesti\u0161 ROS-Base (ker je Ubuntu server, nima smisla name\u0161\u010dati grafi\u010dna orodja) Desni mi\u0161kin klik je \u201cpaste\u201d v cmd. Ko namestis, naredi catkin_ws cd mkdir catkin_ws cd catkin_ws mkdir src cd .. catkin_make Dodaj \u0161e source za ROS spremenljivke echo \"source ~/catkin_ws/devel/setup.bash\" >> ~/.bashrc source ~/.bashrc","title":"Namestitev ROS"},{"location":"additional/#nastavitev-staticnega-ip","text":"Vir S spodnjim ukazom dobi seznam vseh mre\u017enih naprav: ifconfig Poi\u0161\u010di ustrezno mre\u017eno kartico (po navadi je eth0 ). Postavi se v /etc/netplan cd /etc/netplan in odpri 01-netcfg.yaml (\u010de je ni, preveri z ll ) sudo nano /etc/netplan/01-netcfg.yaml Dodaj spodnjo kodo, kjer nastavi\u0161 ustrezne mre\u017ene nastavitve. Pozorni bodite na ustrezne zamike (uporabite presledke ne tabulator). 1 2 3 4 5 6 7 8 9 10 network : ethernets : eth0 : dhcp4 : false addresses : - 192.168.65.60 / 24 gateway4 : 192.168.65.254 nameservers : addresses : [ 192.168.65.14 , 193.2.1.66 ] version : 2 Na koncu ponovno za\u017eeni netplan sudo netplan apply ter preveri, \u010de so nastavitve pravilne z ifconfig","title":"Nastavitev stati\u010dnega IP"},{"location":"additional/#povezava-s-ssh","text":"V Win CMD se pove\u017ee\u0161 s: ssh RPI_uporabnisko_ime@RPI_IP","title":"Povezava s SSH"},{"location":"additional/#povezava-z-vs-code","text":"Sledi navodilom Pozor! Potrebuje\u0161 delujo\u010do mre\u017eno povezavo!","title":"Povezava z VS Code"},{"location":"additional/#gpio-na-raspberrypi","text":"rpi.gpio Namestitev: sudo apt-get update sudo apt-get install python-rpi.gpio Dodaj trenutnega uporabnika v skupino dialout : sudo adduser $USER dialout in ponovno za\u017eeni RPi. Uporaba: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import rospy import RPi.GPIO as GPIO # button GPIO # button 1 - GPIO 11 # button 2 - GPIO 12 # LED GPIO # Green 1 - GPIO 2 # Green 2 - GPIO 3 # Yellow 1 - GPIO 4 # Yellow 2 - GPIO 5 # Red 1 - GPIO 6 # Red 2 - GPIO 7 def resetLed (): # nastavi in resetiraj vse LED for ii in range ( 2 , 8 ): # nastavi IO kot izhode GPIO . setup ( ii , GPIO . OUT ) # postavi izhode na nizek nivo GPIO . output ( ii , False ) if __name__ == '__main__' : # node init rospy . init_node ( 'test_gpio_rpi' ) # set GPIO as BCM GPIO . setmode ( GPIO . BCM ) # reset LED resetLed () # set button1 as input GPIO . setup ( 11 , GPIO . IN ) # set loop to 10 Hz rate = rospy . Rate ( 10 ) while not rospy . is_shutdown (): # read GPIO gpio_state = GPIO . input ( 11 ) \"\"\" interrupt definition GPIO.add_event_detect(gpio_num, detected_edge, callback, bouncetime) GPIO.add_event_detect(BUTTON_GPIO, GPIO.RISING, callback=button_callback, bouncetime=500) \"\"\" GPIO . output ( 2 , False ) if gpio_state : GPIO . output ( 2 , True ) rate . sleep () # clean GPIO settings after stop GPIO . cleanup ()","title":"GPIO na RaspberryPi"},{"location":"additional/#sick-nanoscan3","text":"Manual - wiki 1651 measurements angle resolution: 0.002909 rad scan angle: 275\u00b0","title":"SICK NanoScan3"},{"location":"additional/#install-ros-support","text":"sudo apt-get install ros-melodic-sick-safetyscanners","title":"Install ROS support"},{"location":"additional/#run-the-driver","text":"roslaunch sick_safetyscanners sick_safetyscanners.launch sensor_ip:=<sensor ip> host_ip:=<host ip>","title":"Run the driver"},{"location":"additional/#published-topics","text":"Topic: /sick_safetyscanners/scan Message type: sensor_msgs/LaserScan","title":"Published topics"},{"location":"additional/#linux-ukazi","text":"Uporabni ukazi v Linux okolju Dostop to root direktorija: cd / Premik v prej\u0161njo mapo: cd .. Premik v doma\u010do mapo: cd /home/$user$ cd ~ Izpis trenutne poti: pwd Prika\u017ei vsebino mape: ls Prika\u017ei tudi skrito vsebino mape: ls -l Ustvari novo mapo my_folder : mkdir my_folder Izbri\u0161i prazno mapo my_folder : rmdir my_folder Izbri\u0161i mapo my_folder , ki ni prazna: rm -rf my_folder Spremeni pravice datoteke my_file v executable: chmod +x my_file Ustvari novo datoteko my_file.py touch my_file.py Odpri datoteko my_file.py v Visual Studio Code: code my_file.py Odpri datoteko my_file.py v konzolnem urejevalniku besedila nano : nano my_file.py","title":"Linux ukazi"},{"location":"additional/linux/","text":"Linux ukazi Uporabni ukazi v Linux okolju Dostop to root direktorija: cd / Premik v prej\u0161njo mapo: cd .. Premik v doma\u010do mapo: cd /home/$user$ cd ~ Izpis trenutne poti: pwd Prika\u017ei vsebino mape: ls Prika\u017ei tudi skrito vsebino mape: ls -l Ustvari novo mapo my_folder : mkdir my_folder Izbri\u0161i prazno mapo my_folder : rmdir my_folder Izbri\u0161i mapo my_folder , ki ni prazna: rm -rf my_folder Spremeni pravice datoteke my_file v executable: chmod +x my_file Ustvari novo datoteko my_file.py touch my_file.py Odpri datoteko my_file.py v Visual Studio Code: code my_file.py Odpri datoteko my_file.py v konzolnem urejevalniku besedila nano : nano my_file.py","title":"Linux ukazi"},{"location":"additional/linux/#linux-ukazi","text":"Uporabni ukazi v Linux okolju Dostop to root direktorija: cd / Premik v prej\u0161njo mapo: cd .. Premik v doma\u010do mapo: cd /home/$user$ cd ~ Izpis trenutne poti: pwd Prika\u017ei vsebino mape: ls Prika\u017ei tudi skrito vsebino mape: ls -l Ustvari novo mapo my_folder : mkdir my_folder Izbri\u0161i prazno mapo my_folder : rmdir my_folder Izbri\u0161i mapo my_folder , ki ni prazna: rm -rf my_folder Spremeni pravice datoteke my_file v executable: chmod +x my_file Ustvari novo datoteko my_file.py touch my_file.py Odpri datoteko my_file.py v Visual Studio Code: code my_file.py Odpri datoteko my_file.py v konzolnem urejevalniku besedila nano : nano my_file.py","title":"Linux ukazi"},{"location":"additional/sick/","text":"SICK NanoScan3 Manual - wiki 1651 measurements angle resolution: 0.002909 rad scan angle: 275\u00b0 Install ROS support sudo apt-get install ros-melodic-sick-safetyscanners Run the driver roslaunch sick_safetyscanners sick_safetyscanners.launch sensor_ip:=<sensor ip> host_ip:=<host ip> Published topics Topic: /sick_safetyscanners/scan Message type: sensor_msgs/LaserScan","title":"Sick NanoScan3"},{"location":"additional/sick/#sick-nanoscan3","text":"Manual - wiki 1651 measurements angle resolution: 0.002909 rad scan angle: 275\u00b0","title":"SICK NanoScan3"},{"location":"additional/sick/#install-ros-support","text":"sudo apt-get install ros-melodic-sick-safetyscanners","title":"Install ROS support"},{"location":"additional/sick/#run-the-driver","text":"roslaunch sick_safetyscanners sick_safetyscanners.launch sensor_ip:=<sensor ip> host_ip:=<host ip>","title":"Run the driver"},{"location":"additional/sick/#published-topics","text":"Topic: /sick_safetyscanners/scan Message type: sensor_msgs/LaserScan","title":"Published topics"},{"location":"examples/dirkin/","text":"Direct kinematics for serial mechanism Available functions: A matrices, T6 matrix, Jg matrix, Ja matrix. Code dirkin.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 #!/usr/bin/env python # direktna kinematika za robota UR5e # A matrike # T6 matrika # J matrika # # Sebastjan Slajpah @ Robolab, 2022 # import math import numpy as np import rospy import tf class dirkinUR5e : def __init__ ( self ): # dh parametri self . a = [ 0.00000 , - 0.42500 , - 0.39225 , 0.00000 , 0.00000 , 0.0000 ] self . d = [ 0.1625 , 0.138 , - 0.131 , 0.127 , 0.0997 , 0.0996 ] self . alpha = [ math . pi / 2 , 0 , 0 , math . pi / 2 , - math . pi / 2 , 0 ] self . theta_offset = [ 0 , 0 , 0 , 0 , 0 , 0 ] def hdh ( self , dh_param ): theta = dh_param [ 0 ] d = dh_param [ 1 ] a = dh_param [ 2 ] alpha = dh_param [ 3 ] cos_theta = math . cos ( theta ) sin_theta = math . sin ( theta ) cos_alpha = math . cos ( alpha ) sin_alpha = math . sin ( alpha ) A = np . array ([ [ cos_theta , - sin_theta * cos_alpha , sin_theta * sin_alpha , a * cos_theta ], [ sin_theta , cos_theta * cos_alpha , - cos_theta * sin_alpha , a * sin_theta ], [ 0 , sin_alpha , cos_alpha , d ], [ 0 , 0 , 0 , 1 ]]) return A def dirkinT6 ( self , qq ): A01 = self . hdh ([ qq [ 0 ] + self . theta_offset [ 0 ], self . d [ 0 ], self . a [ 0 ], self . alpha [ 0 ]]) A12 = self . hdh ([ qq [ 1 ] + self . theta_offset [ 1 ], self . d [ 1 ], self . a [ 1 ], self . alpha [ 1 ]]) A23 = self . hdh ([ qq [ 2 ] + self . theta_offset [ 2 ], self . d [ 2 ], self . a [ 2 ], self . alpha [ 2 ]]) A34 = self . hdh ([ qq [ 3 ] + self . theta_offset [ 3 ], self . d [ 3 ], self . a [ 3 ], self . alpha [ 3 ]]) A45 = self . hdh ([ qq [ 4 ] + self . theta_offset [ 4 ], self . d [ 4 ], self . a [ 4 ], self . alpha [ 4 ]]) A56 = self . hdh ([ qq [ 5 ] + self . theta_offset [ 5 ], self . d [ 5 ], self . a [ 5 ], self . alpha [ 5 ]]) self . A01 = A01 self . A02 = np . matmul ( self . A01 , A12 ) self . A03 = np . matmul ( self . A02 , A23 ) self . A04 = np . matmul ( self . A03 , A34 ) self . A05 = np . matmul ( self . A04 , A45 ) self . T6 = np . matmul ( self . A05 , A56 ) return self . T6 def jacobi_G ( self , qq ): Jg = np . zeros (( 6 , 6 )) # izracunaj direktno kinematiko self . dirkinT6 ( qq ) z0 = np . array ([ 0 , 0 , 1 ]) Tn = np . eye ( 4 ) ## 1. sklep p6 = self . T6 [ 0 : 3 , 3 ] Jg [ 0 : 3 , 0 ] = np . cross ( z0 , p6 ) # Jp 1. stolpec Jg [ 3 : 6 , 0 ] = z0 # Jo 1. stolpec ## 2. sklep Tn = self . A01 z_tmp = np . matmul ( Tn [ 0 : 3 , 0 : 3 ], np . transpose ( z0 )) Jg [ 0 : 3 , 1 ] = np . cross ( z_tmp ,( p6 - Tn [ 0 : 3 , 3 ])) # Jp 2. stolpec Jg [ 3 : 6 , 1 ] = z_tmp # Jo 2. stolpec ## 3. sklep Tn = self . A02 z_tmp = np . matmul ( Tn [ 0 : 3 , 0 : 3 ], np . transpose ( z0 )) Jg [ 0 : 3 , 2 ] = np . cross ( z_tmp ,( p6 - Tn [ 0 : 3 , 3 ])) # Jp 3. stolpec Jg [ 3 : 6 , 2 ] = z_tmp # Jo 3. stolpec ## 4. sklep Tn = self . A03 z_tmp = np . matmul ( Tn [ 0 : 3 , 0 : 3 ], np . transpose ( z0 )) Jg [ 0 : 3 , 3 ] = np . cross ( z_tmp ,( p6 - Tn [ 0 : 3 , 3 ])) # Jp 4. stolpec Jg [ 3 : 6 , 3 ] = z_tmp # Jo 4. stolpec ## 5. sklep Tn = self . A04 z_tmp = np . matmul ( Tn [ 0 : 3 , 0 : 3 ], np . transpose ( z0 )) Jg [ 0 : 3 , 4 ] = np . cross ( z_tmp ,( p6 - Tn [ 0 : 3 , 3 ])) # Jp 5. stolpec Jg [ 3 : 6 , 4 ] = z_tmp # Jo 5. stolpec ## 6. sklep Tn = self . A05 z_tmp = np . matmul ( Tn [ 0 : 3 , 0 : 3 ], np . transpose ( z0 )) Jg [ 0 : 3 , 5 ] = np . cross ( z_tmp ,( p6 - Tn [ 0 : 3 , 3 ])) # Jp 6. stolpec Jg [ 3 : 6 , 5 ] = z_tmp # Jo 6. stolpec self . Jg = Jg return Jg def rot_x ( self , angle ): R = np . array ([[ 1 , 0 , 0 ],[ 0 , math . cos ( angle ), - math . sin ( angle )], [ 0 , math . sin ( angle ), math . cos ( angle )]]) return R def rot_y ( self , angle ): R = np . array ([[ math . cos ( angle ), 0 , math . sin ( angle )],[ 0 , 1 , 0 ],[ - math . sin ( angle ), 0 , math . cos ( angle )]]) return R def rot_z ( self , angle ): R = np . array ([[ math . cos ( angle ), - math . sin ( angle ), 0 ],[ math . sin ( angle ), math . cos ( angle ), 0 ],[ 0 , 0 , 1 ]]) return R def Ta_matrix ( self , angles , axes ): T = np . zeros (( 3 , 3 )) if axes [ 0 ] == 'x' : T [ 0 : 3 , 0 ] = np . transpose ([ 1 , 0 , 0 ]) T1 = self . rot_x ( angles [ 0 ]) elif axes [ 0 ] == 'y' : T [ 0 : 3 , 0 ] = np . transpose ([ 0 , 1 , 0 ]) T1 = self . rot_y ( angles [ 0 ]) elif axes [ 0 ] == 'z' : T [ 0 : 3 , 0 ] = np . transpose ([ 0 , 0 , 1 ]) T1 = self . rot_z ( angles [ 0 ]) else : rospy . errorlog ( \"Wrong Euler axes [0] for calculating Ta_matrix\" ) if axes [ 1 ] == 'x' : T2 = np . matmul ( T1 , self . rot_x ( angles [ 1 ])) T [ 0 : 3 , 1 ] = T1 [ 0 : 3 , 0 ] elif axes [ 1 ] == 'y' : T2 = np . matmul ( T1 , self . rot_y ( angles [ 1 ])) T [ 0 : 3 , 1 ] = T1 [ 0 : 3 , 1 ] elif axes [ 1 ] == 'z' : T2 = np . matmul ( T1 , self . rot_z ( angles [ 1 ])) T [ 0 : 3 , 1 ] = T1 [ 0 : 3 , 2 ] else : rospy . errorlog ( \"Wrong Euler axes [1] for calculating Ta_matrix\" ) if axes [ 2 ] == 'x' : T [ 0 : 3 , 2 ] = T2 [ 0 : 3 , 0 ] elif axes [ 2 ] == 'y' : T [ 0 : 3 , 2 ] = T2 [ 0 : 3 , 1 ] elif axes [ 2 ] == 'z' : T [ 0 : 3 , 2 ] = T2 [ 0 : 3 , 2 ] else : rospy . errorlog ( \"Wrong Euler axes [2] for calculating Ta_matrix\" ) Ta = np . identity ( 6 ) Ta [ 3 : 6 , 3 : 6 ] = T self . Ta = Ta return Ta def jacobi_A ( self , qq , axes ): # geometrijski jacobi Jg = self . jacobi_G ( qq ) # eulerjevi koti eul = tf . transformations . euler_from_matrix ( self . T6 , axes = 'r' + axes ) # Ta matrika Ta = self . Ta_matrix ( eul , axes ) # Ja = Ta^-1 Jg Ja = np . matmul ( np . linalg . inv ( Ta ), Jg ) iJa = np . linalg . inv ( Ja ) return Ja , iJa ''' dk_ur =dirkinUR5e() hh = dk_ur.hdh([1,2,3,4]) H6 = dk_ur.dirkinT6([1,2,3,4,5,6]) jg = dk_ur.jacobi_G([1,2,3,4,5,6]) ja, ija, eul = dk_ur.jacobi_A([1,2,3,4,5,6],'zyx') print(ija) print(jg) #print(np.linalg.inv(jg)) dk_ur.Ta_matrix([0,0,0],'zyx') print(ija) ''' File is available at GitHub .","title":"DirKin"},{"location":"examples/dirkin/#direct-kinematics-for-serial-mechanism","text":"Available functions: A matrices, T6 matrix, Jg matrix, Ja matrix.","title":"Direct kinematics for serial mechanism"},{"location":"examples/dirkin/#code","text":"dirkin.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 #!/usr/bin/env python # direktna kinematika za robota UR5e # A matrike # T6 matrika # J matrika # # Sebastjan Slajpah @ Robolab, 2022 # import math import numpy as np import rospy import tf class dirkinUR5e : def __init__ ( self ): # dh parametri self . a = [ 0.00000 , - 0.42500 , - 0.39225 , 0.00000 , 0.00000 , 0.0000 ] self . d = [ 0.1625 , 0.138 , - 0.131 , 0.127 , 0.0997 , 0.0996 ] self . alpha = [ math . pi / 2 , 0 , 0 , math . pi / 2 , - math . pi / 2 , 0 ] self . theta_offset = [ 0 , 0 , 0 , 0 , 0 , 0 ] def hdh ( self , dh_param ): theta = dh_param [ 0 ] d = dh_param [ 1 ] a = dh_param [ 2 ] alpha = dh_param [ 3 ] cos_theta = math . cos ( theta ) sin_theta = math . sin ( theta ) cos_alpha = math . cos ( alpha ) sin_alpha = math . sin ( alpha ) A = np . array ([ [ cos_theta , - sin_theta * cos_alpha , sin_theta * sin_alpha , a * cos_theta ], [ sin_theta , cos_theta * cos_alpha , - cos_theta * sin_alpha , a * sin_theta ], [ 0 , sin_alpha , cos_alpha , d ], [ 0 , 0 , 0 , 1 ]]) return A def dirkinT6 ( self , qq ): A01 = self . hdh ([ qq [ 0 ] + self . theta_offset [ 0 ], self . d [ 0 ], self . a [ 0 ], self . alpha [ 0 ]]) A12 = self . hdh ([ qq [ 1 ] + self . theta_offset [ 1 ], self . d [ 1 ], self . a [ 1 ], self . alpha [ 1 ]]) A23 = self . hdh ([ qq [ 2 ] + self . theta_offset [ 2 ], self . d [ 2 ], self . a [ 2 ], self . alpha [ 2 ]]) A34 = self . hdh ([ qq [ 3 ] + self . theta_offset [ 3 ], self . d [ 3 ], self . a [ 3 ], self . alpha [ 3 ]]) A45 = self . hdh ([ qq [ 4 ] + self . theta_offset [ 4 ], self . d [ 4 ], self . a [ 4 ], self . alpha [ 4 ]]) A56 = self . hdh ([ qq [ 5 ] + self . theta_offset [ 5 ], self . d [ 5 ], self . a [ 5 ], self . alpha [ 5 ]]) self . A01 = A01 self . A02 = np . matmul ( self . A01 , A12 ) self . A03 = np . matmul ( self . A02 , A23 ) self . A04 = np . matmul ( self . A03 , A34 ) self . A05 = np . matmul ( self . A04 , A45 ) self . T6 = np . matmul ( self . A05 , A56 ) return self . T6 def jacobi_G ( self , qq ): Jg = np . zeros (( 6 , 6 )) # izracunaj direktno kinematiko self . dirkinT6 ( qq ) z0 = np . array ([ 0 , 0 , 1 ]) Tn = np . eye ( 4 ) ## 1. sklep p6 = self . T6 [ 0 : 3 , 3 ] Jg [ 0 : 3 , 0 ] = np . cross ( z0 , p6 ) # Jp 1. stolpec Jg [ 3 : 6 , 0 ] = z0 # Jo 1. stolpec ## 2. sklep Tn = self . A01 z_tmp = np . matmul ( Tn [ 0 : 3 , 0 : 3 ], np . transpose ( z0 )) Jg [ 0 : 3 , 1 ] = np . cross ( z_tmp ,( p6 - Tn [ 0 : 3 , 3 ])) # Jp 2. stolpec Jg [ 3 : 6 , 1 ] = z_tmp # Jo 2. stolpec ## 3. sklep Tn = self . A02 z_tmp = np . matmul ( Tn [ 0 : 3 , 0 : 3 ], np . transpose ( z0 )) Jg [ 0 : 3 , 2 ] = np . cross ( z_tmp ,( p6 - Tn [ 0 : 3 , 3 ])) # Jp 3. stolpec Jg [ 3 : 6 , 2 ] = z_tmp # Jo 3. stolpec ## 4. sklep Tn = self . A03 z_tmp = np . matmul ( Tn [ 0 : 3 , 0 : 3 ], np . transpose ( z0 )) Jg [ 0 : 3 , 3 ] = np . cross ( z_tmp ,( p6 - Tn [ 0 : 3 , 3 ])) # Jp 4. stolpec Jg [ 3 : 6 , 3 ] = z_tmp # Jo 4. stolpec ## 5. sklep Tn = self . A04 z_tmp = np . matmul ( Tn [ 0 : 3 , 0 : 3 ], np . transpose ( z0 )) Jg [ 0 : 3 , 4 ] = np . cross ( z_tmp ,( p6 - Tn [ 0 : 3 , 3 ])) # Jp 5. stolpec Jg [ 3 : 6 , 4 ] = z_tmp # Jo 5. stolpec ## 6. sklep Tn = self . A05 z_tmp = np . matmul ( Tn [ 0 : 3 , 0 : 3 ], np . transpose ( z0 )) Jg [ 0 : 3 , 5 ] = np . cross ( z_tmp ,( p6 - Tn [ 0 : 3 , 3 ])) # Jp 6. stolpec Jg [ 3 : 6 , 5 ] = z_tmp # Jo 6. stolpec self . Jg = Jg return Jg def rot_x ( self , angle ): R = np . array ([[ 1 , 0 , 0 ],[ 0 , math . cos ( angle ), - math . sin ( angle )], [ 0 , math . sin ( angle ), math . cos ( angle )]]) return R def rot_y ( self , angle ): R = np . array ([[ math . cos ( angle ), 0 , math . sin ( angle )],[ 0 , 1 , 0 ],[ - math . sin ( angle ), 0 , math . cos ( angle )]]) return R def rot_z ( self , angle ): R = np . array ([[ math . cos ( angle ), - math . sin ( angle ), 0 ],[ math . sin ( angle ), math . cos ( angle ), 0 ],[ 0 , 0 , 1 ]]) return R def Ta_matrix ( self , angles , axes ): T = np . zeros (( 3 , 3 )) if axes [ 0 ] == 'x' : T [ 0 : 3 , 0 ] = np . transpose ([ 1 , 0 , 0 ]) T1 = self . rot_x ( angles [ 0 ]) elif axes [ 0 ] == 'y' : T [ 0 : 3 , 0 ] = np . transpose ([ 0 , 1 , 0 ]) T1 = self . rot_y ( angles [ 0 ]) elif axes [ 0 ] == 'z' : T [ 0 : 3 , 0 ] = np . transpose ([ 0 , 0 , 1 ]) T1 = self . rot_z ( angles [ 0 ]) else : rospy . errorlog ( \"Wrong Euler axes [0] for calculating Ta_matrix\" ) if axes [ 1 ] == 'x' : T2 = np . matmul ( T1 , self . rot_x ( angles [ 1 ])) T [ 0 : 3 , 1 ] = T1 [ 0 : 3 , 0 ] elif axes [ 1 ] == 'y' : T2 = np . matmul ( T1 , self . rot_y ( angles [ 1 ])) T [ 0 : 3 , 1 ] = T1 [ 0 : 3 , 1 ] elif axes [ 1 ] == 'z' : T2 = np . matmul ( T1 , self . rot_z ( angles [ 1 ])) T [ 0 : 3 , 1 ] = T1 [ 0 : 3 , 2 ] else : rospy . errorlog ( \"Wrong Euler axes [1] for calculating Ta_matrix\" ) if axes [ 2 ] == 'x' : T [ 0 : 3 , 2 ] = T2 [ 0 : 3 , 0 ] elif axes [ 2 ] == 'y' : T [ 0 : 3 , 2 ] = T2 [ 0 : 3 , 1 ] elif axes [ 2 ] == 'z' : T [ 0 : 3 , 2 ] = T2 [ 0 : 3 , 2 ] else : rospy . errorlog ( \"Wrong Euler axes [2] for calculating Ta_matrix\" ) Ta = np . identity ( 6 ) Ta [ 3 : 6 , 3 : 6 ] = T self . Ta = Ta return Ta def jacobi_A ( self , qq , axes ): # geometrijski jacobi Jg = self . jacobi_G ( qq ) # eulerjevi koti eul = tf . transformations . euler_from_matrix ( self . T6 , axes = 'r' + axes ) # Ta matrika Ta = self . Ta_matrix ( eul , axes ) # Ja = Ta^-1 Jg Ja = np . matmul ( np . linalg . inv ( Ta ), Jg ) iJa = np . linalg . inv ( Ja ) return Ja , iJa ''' dk_ur =dirkinUR5e() hh = dk_ur.hdh([1,2,3,4]) H6 = dk_ur.dirkinT6([1,2,3,4,5,6]) jg = dk_ur.jacobi_G([1,2,3,4,5,6]) ja, ija, eul = dk_ur.jacobi_A([1,2,3,4,5,6],'zyx') print(ija) print(jg) #print(np.linalg.inv(jg)) dk_ur.Ta_matrix([0,0,0],'zyx') print(ija) ''' File is available at GitHub .","title":"Code"},{"location":"examples/mobile/","text":"Mobile robot control Example python class for controlling mobile robot via velocity control (/cmd_vel) with included odometry and laser scanner SICK NanoScan3 checkup. Code mobile_robot_control.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 #!/usr/bin/env python # example class to control mobile robot # # Sebastjan Slajpah @ Robolab, 2022 # import rospy from nav_msgs.msg import Odometry from geometry_msgs.msg import Twist , Vector3 from sensor_msgs.msg import LaserScan import time class MobileRobotControl (): def __init__ ( self , robot_name = \"YouBot\" ): rospy . init_node ( 'mobile_robot_control_node' , anonymous = True ) cmd_vel_topic = '/cmd_vel' self . _check_laser_ready () # start the publisher self . vel_publisher = rospy . Publisher ( cmd_vel_topic , Twist , queue_size = 1 ) self . cmd = Twist () self . odom_subscriber = rospy . Subscriber ( '/odom' , Odometry , self . odom_callback ) self . sick_laser_subscriber = rospy . Subscriber ( '/sick_nanoscan3/scan' , LaserScan , self . sick_laser_callback ) self . ctrl_c = False self . rate = rospy . Rate ( 10 ) rospy . on_shutdown ( self . shutdownhook ) def _check_odom_ready ( self ): self . odom_msg = None rospy . loginfo ( \"Checking Summit Laser...\" ) while self . odom_msg is None and not rospy . is_shutdown (): try : self . odom_msg = rospy . wait_for_message ( \"/odom\" , Odometry , timeout = 1.0 ) rospy . logdebug ( \"Current /odom READY=>\" + str ( self . odom_msg )) except : rospy . logerr ( \"Current /odom not ready yet, retrying for getting scan\" ) rospy . loginfo ( \"Checking /odom...DONE\" ) return self . odom_msg def _check_laser_ready ( self ): self . laser_msg = None rospy . loginfo ( \"Checking Sick NanoScan3 laser...\" ) while self . laser_msg is None and not rospy . is_shutdown (): try : self . laser_msg = rospy . wait_for_message ( \"/sick_nanoscan3/scan\" , LaserScan , timeout = 1.0 ) rospy . logdebug ( \"Current /sick_nanoscan3/scan READY=>\" + str ( self . laser_msg )) except : rospy . logerr ( \"Current /sick_nanoscan3/scan not ready yet, retrying for getting scan\" ) rospy . loginfo ( \"Checking SICK Nanoscan3...DONE\" ) return self . laser_msg def publish_once_in_cmd_vel ( self ): \"\"\" This is because publishing in topics sometimes fails the first time you publish. In continuous publishing systems, this is no big deal, but in systems that publish only once, it IS very important. \"\"\" while not self . ctrl_c : connections = self . vel_publisher . get_num_connections () if connections > 0 : self . vel_publisher . publish ( self . cmd ) #rospy.loginfo(\"Cmd Published\") break else : self . rate . sleep () def shutdownhook ( self ): # works better than the rospy.is_shutdown() self . stop_robot () self . ctrl_c = True def laser_callback ( self , msg ): self . laser_msg = msg def odom_callback ( self , msg ): self . odom_msg = msg def get_laser ( self , pos ): time . sleep ( 1 ) return self . laser_msg . ranges [ pos ] def get_laser_full ( self ): time . sleep ( 1 ) return self . laser_msg . ranges def stop_robot ( self ): #rospy.loginfo(\"shutdown time! Stop the robot\") self . cmd . linear = Vector3 ( 0.0 , 0.0 , 0.0 ) self . cmd . angular = Vector3 ( 0.0 , 0.0 , 0.0 ) self . publish_once_in_cmd_vel () def move_straight ( self ): # Initilize velocities self . cmd . linear . x = 0.05 self . cmd . linear . y = 0 self . cmd . linear . z = 0 self . cmd . angular . x = 0 self . cmd . angular . y = 0 self . cmd . angular . z = 0 # Publish the velocity self . publish_once_in_cmd_vel () def move_straight_time ( self , motion , speed , time ): # Initilize velocities self . cmd . linear . y = 0 self . cmd . linear . z = 0 self . cmd . angular . x = 0 self . cmd . angular . y = 0 self . cmd . angular . z = 0 if motion == \"forward\" : self . cmd . linear . x = speed elif motion == \"backward\" : self . cmd . linear . x = - speed i = 0 # loop to publish the velocity estimate, current_distance = velocity * (t1 - t0) while ( i <= time ): # Publish the velocity self . vel_publisher . publish ( self . cmd ) i += 1 self . rate . sleep () # set velocity to zero to stop the robot self . stop_robot () s = \"Moved robot \" + motion + \" for \" + str ( time ) + \" seconds\" return s def turn ( self , clockwise , speed , time ): # Initilize velocities self . cmd . linear . x = 0 self . cmd . linear . y = 0 self . cmd . linear . z = 0 self . cmd . angular . x = 0 self . cmd . angular . y = 0 if clockwise == \"clockwise\" : self . cmd . angular . z = - speed else : self . cmd . angular . z = speed i = 0 # loop to publish the velocity estimate, current_distance = velocity * (t1 - t0) while ( i <= time ): # Publish the velocity self . vel_publisher . publish ( self . cmd ) i += 1 self . rate . sleep () # set velocity to zero to stop the robot self . stop_robot () s = \"Turned robot \" + clockwise + \" for \" + str ( time ) + \" seconds\" return s if __name__ == '__main__' : robotcontrol_object = MobileRobotControl () try : robotcontrol_object . move_straight () except rospy . ROSInterruptException : pass File is available at GitHub .","title":"Mobile robot control"},{"location":"examples/mobile/#mobile-robot-control","text":"Example python class for controlling mobile robot via velocity control (/cmd_vel) with included odometry and laser scanner SICK NanoScan3 checkup.","title":"Mobile robot control"},{"location":"examples/mobile/#code","text":"mobile_robot_control.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 #!/usr/bin/env python # example class to control mobile robot # # Sebastjan Slajpah @ Robolab, 2022 # import rospy from nav_msgs.msg import Odometry from geometry_msgs.msg import Twist , Vector3 from sensor_msgs.msg import LaserScan import time class MobileRobotControl (): def __init__ ( self , robot_name = \"YouBot\" ): rospy . init_node ( 'mobile_robot_control_node' , anonymous = True ) cmd_vel_topic = '/cmd_vel' self . _check_laser_ready () # start the publisher self . vel_publisher = rospy . Publisher ( cmd_vel_topic , Twist , queue_size = 1 ) self . cmd = Twist () self . odom_subscriber = rospy . Subscriber ( '/odom' , Odometry , self . odom_callback ) self . sick_laser_subscriber = rospy . Subscriber ( '/sick_nanoscan3/scan' , LaserScan , self . sick_laser_callback ) self . ctrl_c = False self . rate = rospy . Rate ( 10 ) rospy . on_shutdown ( self . shutdownhook ) def _check_odom_ready ( self ): self . odom_msg = None rospy . loginfo ( \"Checking Summit Laser...\" ) while self . odom_msg is None and not rospy . is_shutdown (): try : self . odom_msg = rospy . wait_for_message ( \"/odom\" , Odometry , timeout = 1.0 ) rospy . logdebug ( \"Current /odom READY=>\" + str ( self . odom_msg )) except : rospy . logerr ( \"Current /odom not ready yet, retrying for getting scan\" ) rospy . loginfo ( \"Checking /odom...DONE\" ) return self . odom_msg def _check_laser_ready ( self ): self . laser_msg = None rospy . loginfo ( \"Checking Sick NanoScan3 laser...\" ) while self . laser_msg is None and not rospy . is_shutdown (): try : self . laser_msg = rospy . wait_for_message ( \"/sick_nanoscan3/scan\" , LaserScan , timeout = 1.0 ) rospy . logdebug ( \"Current /sick_nanoscan3/scan READY=>\" + str ( self . laser_msg )) except : rospy . logerr ( \"Current /sick_nanoscan3/scan not ready yet, retrying for getting scan\" ) rospy . loginfo ( \"Checking SICK Nanoscan3...DONE\" ) return self . laser_msg def publish_once_in_cmd_vel ( self ): \"\"\" This is because publishing in topics sometimes fails the first time you publish. In continuous publishing systems, this is no big deal, but in systems that publish only once, it IS very important. \"\"\" while not self . ctrl_c : connections = self . vel_publisher . get_num_connections () if connections > 0 : self . vel_publisher . publish ( self . cmd ) #rospy.loginfo(\"Cmd Published\") break else : self . rate . sleep () def shutdownhook ( self ): # works better than the rospy.is_shutdown() self . stop_robot () self . ctrl_c = True def laser_callback ( self , msg ): self . laser_msg = msg def odom_callback ( self , msg ): self . odom_msg = msg def get_laser ( self , pos ): time . sleep ( 1 ) return self . laser_msg . ranges [ pos ] def get_laser_full ( self ): time . sleep ( 1 ) return self . laser_msg . ranges def stop_robot ( self ): #rospy.loginfo(\"shutdown time! Stop the robot\") self . cmd . linear = Vector3 ( 0.0 , 0.0 , 0.0 ) self . cmd . angular = Vector3 ( 0.0 , 0.0 , 0.0 ) self . publish_once_in_cmd_vel () def move_straight ( self ): # Initilize velocities self . cmd . linear . x = 0.05 self . cmd . linear . y = 0 self . cmd . linear . z = 0 self . cmd . angular . x = 0 self . cmd . angular . y = 0 self . cmd . angular . z = 0 # Publish the velocity self . publish_once_in_cmd_vel () def move_straight_time ( self , motion , speed , time ): # Initilize velocities self . cmd . linear . y = 0 self . cmd . linear . z = 0 self . cmd . angular . x = 0 self . cmd . angular . y = 0 self . cmd . angular . z = 0 if motion == \"forward\" : self . cmd . linear . x = speed elif motion == \"backward\" : self . cmd . linear . x = - speed i = 0 # loop to publish the velocity estimate, current_distance = velocity * (t1 - t0) while ( i <= time ): # Publish the velocity self . vel_publisher . publish ( self . cmd ) i += 1 self . rate . sleep () # set velocity to zero to stop the robot self . stop_robot () s = \"Moved robot \" + motion + \" for \" + str ( time ) + \" seconds\" return s def turn ( self , clockwise , speed , time ): # Initilize velocities self . cmd . linear . x = 0 self . cmd . linear . y = 0 self . cmd . linear . z = 0 self . cmd . angular . x = 0 self . cmd . angular . y = 0 if clockwise == \"clockwise\" : self . cmd . angular . z = - speed else : self . cmd . angular . z = speed i = 0 # loop to publish the velocity estimate, current_distance = velocity * (t1 - t0) while ( i <= time ): # Publish the velocity self . vel_publisher . publish ( self . cmd ) i += 1 self . rate . sleep () # set velocity to zero to stop the robot self . stop_robot () s = \"Turned robot \" + clockwise + \" for \" + str ( time ) + \" seconds\" return s if __name__ == '__main__' : robotcontrol_object = MobileRobotControl () try : robotcontrol_object . move_straight () except rospy . ROSInterruptException : pass File is available at GitHub .","title":"Code"},{"location":"examples/robot/","text":"Robot control Example python class for controlling serial robot via Cartesian velocity control (twist control) with included force/torque measurements (wrench). Code robot_control.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #!/usr/bin/env python # example class to control UR5e robot # # Sebastjan Slajpah @ Robolab, 2022 # import rospy from geometry_msgs.msg import Twist , Vector3 , WrenchStamped class RobotControl (): def __init__ ( self ): rospy . init_node ( 'robot_control_node' , anonymous = True ) cmd_vel_topic = '/twist_controller/command' self . _check_wrench_ready () # start the publisher self . vel_publisher = rospy . Publisher ( cmd_vel_topic , Twist , queue_size = 1 ) self . cmd = Twist () self . wrench_subscriber = rospy . Subscriber ( '/wrench' , WrenchStamped , self . wrench_callback ) self . ctrl_c = False self . rate = rospy . Rate ( 1 ) rospy . on_shutdown ( self . shutdownhook ) def _check_wrench_ready ( self ): self . wrench_msg = None rospy . loginfo ( \"Checking wrench ...\" ) while self . wrench_msg is None and not rospy . is_shutdown (): try : self . wrench_msg = rospy . wait_for_message ( \"/wrench\" , WrenchStamped , timeout = 1.0 ) rospy . logdebug ( \"Current /wrench READY=>\" + str ( self . wrench_msg )) except : rospy . logerr ( \"Current /wrench not ready yet, retrying for getting scan\" ) rospy . loginfo ( \"Checking /wrench...DONE\" ) return self . wrench_msg def publish_once_in_cmd_vel ( self ): \"\"\" This is because publishing in topics sometimes fails the first time you publish. In continuous publishing systems, this is no big deal, but in systems that publish only once, it IS very important. \"\"\" while not self . ctrl_c : connections = self . vel_publisher . get_num_connections () if connections > 0 : self . vel_publisher . publish ( self . cmd ) #rospy.loginfo(\"Cmd Published\") break else : self . rate . sleep () def shutdownhook ( self ): # works better than the rospy.is_shutdown() self . stop_robot () self . ctrl_c = True def wrench_callback ( self , msg ): self . wrench_msg = msg def stop_robot ( self ): #rospy.loginfo(\"shutdown time! Stop the robot\") self . cmd . linear = Vector3 ( 0.0 , 0.0 , 0.0 ) self . cmd . angular = Vector3 ( 0.0 , 0.0 , 0.0 ) self . publish_once_in_cmd_vel () def move_straight ( self ): # Initilize velocities self . cmd . linear . x = 0 self . cmd . linear . y = 0 self . cmd . linear . z = 0.05 self . cmd . angular . x = 0 self . cmd . angular . y = 0 self . cmd . angular . z = 0 # Publish the velocity self . publish_once_in_cmd_vel () def move_straight_time ( self , motion , speed , time ): # Initilize velocities self . cmd . linear . y = 0 self . cmd . linear . z = 0 self . cmd . angular . x = 0 self . cmd . angular . y = 0 self . cmd . angular . z = 0 if motion == \"up\" : self . cmd . linear . z = speed elif motion == \"down\" : self . cmd . linear . z = - speed i = 0 # loop to publish the velocity estimate, current_distance = velocity * (t1 - t0) while ( i <= time ): # Publish the velocity self . vel_publisher . publish ( self . cmd ) i += 1 self . rate . sleep () print ( self . wrench_msg . forces . z ) # set velocity to zero to stop the robot self . stop_robot () s = \"Moved robot \" + motion + \" for \" + str ( time ) + \" seconds\" return s if __name__ == '__main__' : robotcontrol_object = RobotControl () try : robotcontrol_object . move_straight_time ( 'up' , 0.0 , 3 ) # objekt robotcontrol_object.move_straight_time('up',0.0, 3) direction' up' speed 0.o 3=time (s) except rospy . ROSInterruptException : pass File is available at GitHub .","title":"Robot control"},{"location":"examples/robot/#robot-control","text":"Example python class for controlling serial robot via Cartesian velocity control (twist control) with included force/torque measurements (wrench).","title":"Robot control"},{"location":"examples/robot/#code","text":"robot_control.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #!/usr/bin/env python # example class to control UR5e robot # # Sebastjan Slajpah @ Robolab, 2022 # import rospy from geometry_msgs.msg import Twist , Vector3 , WrenchStamped class RobotControl (): def __init__ ( self ): rospy . init_node ( 'robot_control_node' , anonymous = True ) cmd_vel_topic = '/twist_controller/command' self . _check_wrench_ready () # start the publisher self . vel_publisher = rospy . Publisher ( cmd_vel_topic , Twist , queue_size = 1 ) self . cmd = Twist () self . wrench_subscriber = rospy . Subscriber ( '/wrench' , WrenchStamped , self . wrench_callback ) self . ctrl_c = False self . rate = rospy . Rate ( 1 ) rospy . on_shutdown ( self . shutdownhook ) def _check_wrench_ready ( self ): self . wrench_msg = None rospy . loginfo ( \"Checking wrench ...\" ) while self . wrench_msg is None and not rospy . is_shutdown (): try : self . wrench_msg = rospy . wait_for_message ( \"/wrench\" , WrenchStamped , timeout = 1.0 ) rospy . logdebug ( \"Current /wrench READY=>\" + str ( self . wrench_msg )) except : rospy . logerr ( \"Current /wrench not ready yet, retrying for getting scan\" ) rospy . loginfo ( \"Checking /wrench...DONE\" ) return self . wrench_msg def publish_once_in_cmd_vel ( self ): \"\"\" This is because publishing in topics sometimes fails the first time you publish. In continuous publishing systems, this is no big deal, but in systems that publish only once, it IS very important. \"\"\" while not self . ctrl_c : connections = self . vel_publisher . get_num_connections () if connections > 0 : self . vel_publisher . publish ( self . cmd ) #rospy.loginfo(\"Cmd Published\") break else : self . rate . sleep () def shutdownhook ( self ): # works better than the rospy.is_shutdown() self . stop_robot () self . ctrl_c = True def wrench_callback ( self , msg ): self . wrench_msg = msg def stop_robot ( self ): #rospy.loginfo(\"shutdown time! Stop the robot\") self . cmd . linear = Vector3 ( 0.0 , 0.0 , 0.0 ) self . cmd . angular = Vector3 ( 0.0 , 0.0 , 0.0 ) self . publish_once_in_cmd_vel () def move_straight ( self ): # Initilize velocities self . cmd . linear . x = 0 self . cmd . linear . y = 0 self . cmd . linear . z = 0.05 self . cmd . angular . x = 0 self . cmd . angular . y = 0 self . cmd . angular . z = 0 # Publish the velocity self . publish_once_in_cmd_vel () def move_straight_time ( self , motion , speed , time ): # Initilize velocities self . cmd . linear . y = 0 self . cmd . linear . z = 0 self . cmd . angular . x = 0 self . cmd . angular . y = 0 self . cmd . angular . z = 0 if motion == \"up\" : self . cmd . linear . z = speed elif motion == \"down\" : self . cmd . linear . z = - speed i = 0 # loop to publish the velocity estimate, current_distance = velocity * (t1 - t0) while ( i <= time ): # Publish the velocity self . vel_publisher . publish ( self . cmd ) i += 1 self . rate . sleep () print ( self . wrench_msg . forces . z ) # set velocity to zero to stop the robot self . stop_robot () s = \"Moved robot \" + motion + \" for \" + str ( time ) + \" seconds\" return s if __name__ == '__main__' : robotcontrol_object = RobotControl () try : robotcontrol_object . move_straight_time ( 'up' , 0.0 , 3 ) # objekt robotcontrol_object.move_straight_time('up',0.0, 3) direction' up' speed 0.o 3=time (s) except rospy . ROSInterruptException : pass File is available at GitHub .","title":"Code"},{"location":"introduction/","text":"Introduction to ROS Welcome to the ROS FE workshop. In this part of the workshop you will learn the fundamentals of ROS. Why ROS? ROS is an open-source, meta-operating system for your robot. It provides the services you would expect from an operating system, including hardware abstraction, low-level device control, implementation of commonly-used functionality, message-passing between processes, and package management. It also provides tools and libraries for obtaining, building, writing, and running code across multiple computers. ROS has three levels of concepts: the Filesystem level, the Computation Graph level, and the Community level. ROS Filesystem Level The basic unit for software code organization in ROS is a package. It can contain code for processes, liberaries, datasets, configuration files and custom communication types definitions. Packages can be sensibly grouped into metapackages. Each package contains a package manifest (package.xml) that provides the metadata about the package. ROS Computation Graph Level In ROS, processes run as nodes in a peer-to-peer network processing data together. This network is called ROS Computation Graph and it is supported by the name registration and lookup services of the ROS Master, by the parameter storing and serving services of the Parameter Server, and by the ROS logging mechanism. ROS nodes communicate by excanging data using messages in communication models called topics, services and actions. ROS Community Level There is a large number of ROS developers and robotic systems developers using ROS worldwide. Separate communities can exchange software and knowledge using ROS distributions, code repositories, the ROS Wiki and ROS Answers forums, blog and mailing lists. To get the participants of this course acquainted with the availabe resources, reading through some of the ROS Wiki topics will be encouraged by providing links to the ROS Wiki contents.","title":"About ROS"},{"location":"introduction/#introduction-to-ros","text":"Welcome to the ROS FE workshop. In this part of the workshop you will learn the fundamentals of ROS.","title":"Introduction to ROS"},{"location":"introduction/#why-ros","text":"ROS is an open-source, meta-operating system for your robot. It provides the services you would expect from an operating system, including hardware abstraction, low-level device control, implementation of commonly-used functionality, message-passing between processes, and package management. It also provides tools and libraries for obtaining, building, writing, and running code across multiple computers. ROS has three levels of concepts: the Filesystem level, the Computation Graph level, and the Community level.","title":"Why ROS?"},{"location":"introduction/#ros-filesystem-level","text":"The basic unit for software code organization in ROS is a package. It can contain code for processes, liberaries, datasets, configuration files and custom communication types definitions. Packages can be sensibly grouped into metapackages. Each package contains a package manifest (package.xml) that provides the metadata about the package.","title":"ROS Filesystem Level"},{"location":"introduction/#ros-computation-graph-level","text":"In ROS, processes run as nodes in a peer-to-peer network processing data together. This network is called ROS Computation Graph and it is supported by the name registration and lookup services of the ROS Master, by the parameter storing and serving services of the Parameter Server, and by the ROS logging mechanism. ROS nodes communicate by excanging data using messages in communication models called topics, services and actions.","title":"ROS Computation Graph Level"},{"location":"introduction/#ros-community-level","text":"There is a large number of ROS developers and robotic systems developers using ROS worldwide. Separate communities can exchange software and knowledge using ROS distributions, code repositories, the ROS Wiki and ROS Answers forums, blog and mailing lists. To get the participants of this course acquainted with the availabe resources, reading through some of the ROS Wiki topics will be encouraged by providing links to the ROS Wiki contents.","title":"ROS Community Level"},{"location":"introduction/actions/","text":"Actions actionlib library server/client system asynchronous operation used for longer lasting functionalities you can perform other tasks while basic functionality is called action msg is composed of individual messages for Goal, Feedback and Result How to recognise action? Use rostopic list and look for the following structure ( as stands for action server ): as_name/cancel as_name/feedback as_name/goal as_name/result as_name/status ( as_name is action server namespace). Action MSG Action msgs can be defined in package rpi_msgs . Create new folder action and inside new file runningLed.action . roscd rpi_msgs mkdir action cd ./action touch runningLed.action code runnngLed.action Copy the following acton msg definition: runningLed.action 1 2 3 4 5 6 7 8 # goal int16 numberOfRuns --- # result int16 finalRun --- # feedback int16 currentRun In CMakeLists.txt of the rpi_msgs package change the following lines: CMakeLists.txt 10 11 12 13 14 15 find_package(catkin REQUIRED COMPONENTS rospy std_msgs message_generation actionlib_msgs ) CMakeLists.txt 62 63 64 65 add_action_files( FILES runningLed.action ) CMakeLists.txt 69 70 71 72 73 generate_messages( DEPENDENCIES std_msgs actionlib_msgs ) In package.xml of the rpi_msgs package add the following line: package.xml 60 <build_depend> actionlib_msgs </build_depend> Then do catkin_make in catkin_ws folder. Example Turn on sequential LEDs n-times. Action server Simple action server sytnax: 1 2 3 4 5 6 7 8 9 sas = actionlib . SimpleActionServer ( 'name' , actionSpec , goal_callback , auto_start = False ) sas . start () def goal_callback () sas . publish_feedback ( _feedback_ ) sas . set_succeeded ( _result_ ) if sas . is_preempt_requested (): sas . set_preempted () Example code for simple action server: ledrun_server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/usr/bin/env python import rospy import RPi.GPIO as GPIO # include actionlib import actionlib # include action msgs from rpi_msgs.msg import runningLedFeedback , runningLedResult , runningLedAction class runled_server (): def __init__ ( self ): # init variables # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define simple action server # actionlib.SimpleActionServer('action_name', actionType, callback, autostart) self . ACserver = actionlib . SimpleActionServer ( 'run_led' , runningLedAction , self . goal_callback , False ) # run server self . ACserver . start () print ( 'Server pripravljen' ) # define loop frequency (6 Hz) self . r = rospy . Rate ( 6 ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def goal_callback ( self , goal ): # Do lots of awesome groundbreaking robot stuff here self . resetLed () # print number of iterations print ( \"Stevilo iteracij: %i \" % goal . numberOfRuns ) # define feedback variable feedback1 = runningLedFeedback () # define result variable result1 = runningLedResult () success = True doPreemt = False # do number of iterations for kk in range ( 1 , goal . numberOfRuns + 1 ): # turn on individual LED (GPIO 2 - GPIO 7) for ii in range ( 2 , 8 ): # check if there was a preemt request if self . ACserver . is_preempt_requested (): # skip other interations print ( 'Goal preempted.' ) # definie result result1 . finalRun = kk # in case of preemt send result and text self . ACserver . set_preempted ( result = result1 , text = 'Goal preemted.' ) success = False doPreemt = True # break inside loop - turning on individual LEDs break ############################### # ACTIONS # clear all LED self . resetLed () # turn on LED i GPIO . output ( ii , True ) # 6 Hz self . r . sleep () ############################### # in case of preemt, break outside loop - iterations if doPreemt : break # send feedback after each interation feedback1 . currentRun = kk self . ACserver . publish_feedback ( feedback1 ) # send result after all iterations if success : # define results result1 . finalRun = feedback1 . currentRun # log rospy . loginfo ( 'Zakljuceno - Succeeded' ) # poslji rezultat self . ACserver . set_succeeded ( result1 ) def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'runled_server' ) # initialise class runled = runled_server () # reset leds runled . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass Action client Simple action client syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 client = actionlib . SimpleActionClient ( 'name' , actionSpec ) client . send_goal ( goal ) # Sends the goal to the action server. client . wait_for_result () # Waits for the server to finish performing the action. client . get_result () # Prints out the result of executing the action client . get_state () # Get current state of the server # define action server status PENDING = 0 ACTIVE = 1 DONE = 2 WARN = 3 ERROR = 4 Example code for simple action client: ledrun_client.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #!/usr/bin/env python import rospy # import actionlib import actionlib # import action msgs from rpi_msgs.msg import runningLedAction , runningLedGoal , runningLedResult # define action server status PENDING = 0 ACTIVE = 1 DONE = 2 WARN = 3 ERROR = 4 class runled_client (): def __init__ ( self ): # define simple action client # actionlib.SimpleActionClient('action:name', actionType) self . client = actionlib . SimpleActionClient ( 'run_led' , runningLedAction ) # wait, until server isnt active self . client . wait_for_server () rospy . loginfo ( \"Server is active.\" ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def run_led_client ( self , goalNum ): # define goal goal = runningLedGoal () goal . numberOfRuns = goalNum # send goal self . client . send_goal ( goal ) ''' ################################### # FOR PREEMT TESTING # after 3 s send new goal rospy.sleep(3) goal.numberOfRuns = 2 self.client.send_goal(goal) print('New goal was sent.') ################################### ''' # OPTION A - wait, until server doesn finish (similar to service) self . client . wait_for_result () ''' # OPTION B - do something else while you are waiting ## read current server state current_state = self.client.get_state() ## define loop frequency 1 Hz r2 = rospy.Rate(1) # until server status isnt DONE, do something else while current_state < DONE: # action is running, so do somethin productive # check state current_state = self.client.get_state() # 1 Hz r2.sleep() # is the server state is WARN if current_state == WARN: rospy.logwarn(\"Warning on the action server side.\") # if the server state is ERROR if current_state == ERROR: rospy.logerr(\"Error on the action server side.\") ''' # return result return self . client . get_result () def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'run_led_client' ) # initialise class runled = runled_client () try : # poslji goal result = runled . run_led_client ( goalNum = 10 ) # izpisi rezultat print ( \"Result: %i \" % result . finalRun ) except rospy . ROSInterruptException : # v primeru napake print ( \"Program interrupted before completion.\" ) Exercise Stop execution of LEDs sequential blinking if the object is closer that 20 cm.","title":"Action"},{"location":"introduction/actions/#actions","text":"actionlib library server/client system asynchronous operation used for longer lasting functionalities you can perform other tasks while basic functionality is called action msg is composed of individual messages for Goal, Feedback and Result How to recognise action? Use rostopic list and look for the following structure ( as stands for action server ): as_name/cancel as_name/feedback as_name/goal as_name/result as_name/status ( as_name is action server namespace).","title":"Actions"},{"location":"introduction/actions/#action-msg","text":"Action msgs can be defined in package rpi_msgs . Create new folder action and inside new file runningLed.action . roscd rpi_msgs mkdir action cd ./action touch runningLed.action code runnngLed.action Copy the following acton msg definition: runningLed.action 1 2 3 4 5 6 7 8 # goal int16 numberOfRuns --- # result int16 finalRun --- # feedback int16 currentRun In CMakeLists.txt of the rpi_msgs package change the following lines: CMakeLists.txt 10 11 12 13 14 15 find_package(catkin REQUIRED COMPONENTS rospy std_msgs message_generation actionlib_msgs ) CMakeLists.txt 62 63 64 65 add_action_files( FILES runningLed.action ) CMakeLists.txt 69 70 71 72 73 generate_messages( DEPENDENCIES std_msgs actionlib_msgs ) In package.xml of the rpi_msgs package add the following line: package.xml 60 <build_depend> actionlib_msgs </build_depend> Then do catkin_make in catkin_ws folder.","title":"Action MSG"},{"location":"introduction/actions/#example","text":"Turn on sequential LEDs n-times.","title":"Example"},{"location":"introduction/actions/#action-server","text":"Simple action server sytnax: 1 2 3 4 5 6 7 8 9 sas = actionlib . SimpleActionServer ( 'name' , actionSpec , goal_callback , auto_start = False ) sas . start () def goal_callback () sas . publish_feedback ( _feedback_ ) sas . set_succeeded ( _result_ ) if sas . is_preempt_requested (): sas . set_preempted () Example code for simple action server: ledrun_server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/usr/bin/env python import rospy import RPi.GPIO as GPIO # include actionlib import actionlib # include action msgs from rpi_msgs.msg import runningLedFeedback , runningLedResult , runningLedAction class runled_server (): def __init__ ( self ): # init variables # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define simple action server # actionlib.SimpleActionServer('action_name', actionType, callback, autostart) self . ACserver = actionlib . SimpleActionServer ( 'run_led' , runningLedAction , self . goal_callback , False ) # run server self . ACserver . start () print ( 'Server pripravljen' ) # define loop frequency (6 Hz) self . r = rospy . Rate ( 6 ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def goal_callback ( self , goal ): # Do lots of awesome groundbreaking robot stuff here self . resetLed () # print number of iterations print ( \"Stevilo iteracij: %i \" % goal . numberOfRuns ) # define feedback variable feedback1 = runningLedFeedback () # define result variable result1 = runningLedResult () success = True doPreemt = False # do number of iterations for kk in range ( 1 , goal . numberOfRuns + 1 ): # turn on individual LED (GPIO 2 - GPIO 7) for ii in range ( 2 , 8 ): # check if there was a preemt request if self . ACserver . is_preempt_requested (): # skip other interations print ( 'Goal preempted.' ) # definie result result1 . finalRun = kk # in case of preemt send result and text self . ACserver . set_preempted ( result = result1 , text = 'Goal preemted.' ) success = False doPreemt = True # break inside loop - turning on individual LEDs break ############################### # ACTIONS # clear all LED self . resetLed () # turn on LED i GPIO . output ( ii , True ) # 6 Hz self . r . sleep () ############################### # in case of preemt, break outside loop - iterations if doPreemt : break # send feedback after each interation feedback1 . currentRun = kk self . ACserver . publish_feedback ( feedback1 ) # send result after all iterations if success : # define results result1 . finalRun = feedback1 . currentRun # log rospy . loginfo ( 'Zakljuceno - Succeeded' ) # poslji rezultat self . ACserver . set_succeeded ( result1 ) def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'runled_server' ) # initialise class runled = runled_server () # reset leds runled . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass","title":"Action server"},{"location":"introduction/actions/#action-client","text":"Simple action client syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 client = actionlib . SimpleActionClient ( 'name' , actionSpec ) client . send_goal ( goal ) # Sends the goal to the action server. client . wait_for_result () # Waits for the server to finish performing the action. client . get_result () # Prints out the result of executing the action client . get_state () # Get current state of the server # define action server status PENDING = 0 ACTIVE = 1 DONE = 2 WARN = 3 ERROR = 4 Example code for simple action client: ledrun_client.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #!/usr/bin/env python import rospy # import actionlib import actionlib # import action msgs from rpi_msgs.msg import runningLedAction , runningLedGoal , runningLedResult # define action server status PENDING = 0 ACTIVE = 1 DONE = 2 WARN = 3 ERROR = 4 class runled_client (): def __init__ ( self ): # define simple action client # actionlib.SimpleActionClient('action:name', actionType) self . client = actionlib . SimpleActionClient ( 'run_led' , runningLedAction ) # wait, until server isnt active self . client . wait_for_server () rospy . loginfo ( \"Server is active.\" ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def run_led_client ( self , goalNum ): # define goal goal = runningLedGoal () goal . numberOfRuns = goalNum # send goal self . client . send_goal ( goal ) ''' ################################### # FOR PREEMT TESTING # after 3 s send new goal rospy.sleep(3) goal.numberOfRuns = 2 self.client.send_goal(goal) print('New goal was sent.') ################################### ''' # OPTION A - wait, until server doesn finish (similar to service) self . client . wait_for_result () ''' # OPTION B - do something else while you are waiting ## read current server state current_state = self.client.get_state() ## define loop frequency 1 Hz r2 = rospy.Rate(1) # until server status isnt DONE, do something else while current_state < DONE: # action is running, so do somethin productive # check state current_state = self.client.get_state() # 1 Hz r2.sleep() # is the server state is WARN if current_state == WARN: rospy.logwarn(\"Warning on the action server side.\") # if the server state is ERROR if current_state == ERROR: rospy.logerr(\"Error on the action server side.\") ''' # return result return self . client . get_result () def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'run_led_client' ) # initialise class runled = runled_client () try : # poslji goal result = runled . run_led_client ( goalNum = 10 ) # izpisi rezultat print ( \"Result: %i \" % result . finalRun ) except rospy . ROSInterruptException : # v primeru napake print ( \"Program interrupted before completion.\" )","title":"Action client"},{"location":"introduction/actions/#exercise","text":"Stop execution of LEDs sequential blinking if the object is closer that 20 cm.","title":"Exercise"},{"location":"introduction/debug/","text":"ROS Debug tools Logging 5 logging levels: DEBUG INFO WARN ERROR FATAL Code example 1 2 3 4 5 6 7 8 rospy . init_node ( 'log_demo' , log_level = rospy . DEBUG ) while not rospy . is_shutdown (): rospy . logdebug ( \"Debug msg\" ) rospy . loginfo ( \"Info msg\" ) rospy . logwarn ( \"Warning msg\" ) rospy . logerr ( \"Error msg\" ) rospy . logfatal ( \"Fatal msg\" ) rqt_console GUI for log messages. rqt_console rqt_plot Graphical plot of signals from selected topics. rqt_plot rqt_graph Shows connection between nodes in the system. rqt_graph RViz RViz visually represents data from topics. RViz is NOT a simulation, it represents the current state of the robot rosrun rviz rviz","title":"Debug tools"},{"location":"introduction/debug/#ros-debug-tools","text":"","title":"ROS Debug tools"},{"location":"introduction/debug/#logging","text":"5 logging levels: DEBUG INFO WARN ERROR FATAL Code example 1 2 3 4 5 6 7 8 rospy . init_node ( 'log_demo' , log_level = rospy . DEBUG ) while not rospy . is_shutdown (): rospy . logdebug ( \"Debug msg\" ) rospy . loginfo ( \"Info msg\" ) rospy . logwarn ( \"Warning msg\" ) rospy . logerr ( \"Error msg\" ) rospy . logfatal ( \"Fatal msg\" )","title":"Logging"},{"location":"introduction/debug/#rqt_console","text":"GUI for log messages. rqt_console","title":"rqt_console"},{"location":"introduction/debug/#rqt_plot","text":"Graphical plot of signals from selected topics. rqt_plot","title":"rqt_plot"},{"location":"introduction/debug/#rqt_graph","text":"Shows connection between nodes in the system. rqt_graph","title":"rqt_graph"},{"location":"introduction/debug/#rviz","text":"RViz visually represents data from topics. RViz is NOT a simulation, it represents the current state of the robot rosrun rviz rviz","title":"RViz"},{"location":"introduction/exampleRPI/","text":"ROS setup roscore takes care of communicaiton between different ROS functionalities it can run only one at once connects different ROS system into one ROS network roscore catkin workspace CATKIN is an official build system for ROS cd mkdir catkin_ws cd catkin_ws mkdir src catkin_make Alternative is to use catkin build (beforehand you need to remove devel and build folders). Conect console with ROS variables cd devel source setup.bash To do this automatically when the console is opened, add to bashrc.sh echo \"source ~/catkin_ws/devel/setup.bash\" >> ~/.bashrc source ~/.bashrc Packages Packages are independent units, that can be re-used. New package Go to catkin_ws/src/ folder. Basic syntax: catkin_create_pkg <package_name> [depend1] [depend2] [depend3] Create new package rpi_test : cd ~/catkin_ws/src catkin_create_pkg rpi_test rospy std_msgs cd .. catkin_make Node Nodes are processes: used for calculations, that run inside robotic application, grouped into packages, that communicate with each other (topics, servers, actions, parameter servers). Why to use nodes: reduce code complexity, the code is more error-resistant, use of different programming languages. New node Nodes are scripts that are located inside scripts folder. roscd rpi_test mkdir scripts cd scripts Create new script my_first_node.py : touch my_first_node.py Change the access permissions of the file to executable: chmod +x my_first_node.py Open script with Visual Studio Code: code my_first_node.py The minimal working example for node: my_fist_node.py 1 2 3 4 5 6 7 8 9 #!/usr/bin/env python import rospy if __name__ == '__main__' : rospy . init_node ( 'my_first_python_node' ) rospy . loginfo ( 'This node has been started.' ) rospy . sleep ( 1 ) print ( 'Exit now' ) Only one node with specific name can be run at a time. If you want to run more instances of the same node, change: 6 rospy . init_node ( 'my_first_python_node' , anonymous = True ) To run, write python my_first_node.py New node - class my_fist_node_class.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/env python import rospy class hello_world (): def __init__ ( self ): # init variables self . delay = 5 self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c rospy . loginfo ( 'This node has been terminated.' ) self . ctrl_c = True def test_node ( self ): rospy . loginfo ( 'This node has been started.' ) rospy . sleep ( self . delay ) print ( 'Exit now' ) if __name__ == '__main__' : # initialise node rospy . init_node ( 'my_first_python_node' ) # initialise class first_node = hello_world () try : first_node . test_node () except rospy . ROSInterruptException : pass DEBUG rosrun <pkg name> <node name> - run specific node rosnode list - list of all active nodes rosnode info <node name> - information about hte node rosnode kill <node name> - shut down node rosnode ping <node name> - ping node (check, if it is working) Examples for Raspberry Pi Download examples on RaspberryPi. Go to src directory: roscd cd .. cd src Clone from GitHub: git clone https://github.com/ROS-FE/rpi_ros_examples.git . Build the packages: roscd cd .. catkin_make Topics Topic is: a communication channel through which nodes exchange messages one-way messaging (publisher> subscriber) anonymous topic has its own message type ( list of standars message types ) ROS master takes care of the proper publisher/subscriber connection each node can have multiple publishers/subscribers for different topics Example Turn on LED on button press. Publisher Syntax for publisher: pub = rospy . Publisher ( '/topic_name' , msg_type , queue_size = 10 ) Example code: button_publisher.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #!/usr/bin/env python import rospy import RPi.GPIO as GPIO from std_msgs.msg import Bool # buttons GPIO pins # button 1 - gpio 11 # button 2 - gpio 12 class rpi_button (): def __init__ ( self ): # init variables self . BUTTON_GPIO = 11 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set button IO as input GPIO . setup ( self . BUTTON_GPIO , GPIO . IN ) # set loop frequency to 10 Hz self . rate = rospy . Rate ( 10 ) # define publisher # rospy.Publisher(\"topic_name\", varType, queue_size) self . pub = rospy . Publisher ( '/button_state' , Bool , queue_size = 10 ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def read_button ( self ): while not self . ctrl_c : # read GPIO pin gpio_state = GPIO . input ( self . BUTTON_GPIO ) # define msg as Bool variable self . msg = Bool () # msg has a data \"data\" self . msg . data = gpio_state # send msg self . publish_once () def publish_once ( self ): \"\"\" This is because publishing in topics sometimes fails the first time you publish. In continuous publishing systems, this is no big deal, but in systems that publish only once, it IS very important. \"\"\" while not self . ctrl_c : connections = self . pub . get_num_connections () if connections > 0 : self . pub . publish ( self . msg ) #rospy.loginfo(\"Msg Published\") break else : self . rate . sleep () def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all GPIO settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'button_state_publisher' , anonymous = True ) # initialise class btn = rpi_button () try : btn . read_button () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros button_publisher.py check the list of topics (look for /button_state ) rostopic list Then listen to that topic rostopic echo /button_state -c and press the button on RaspberryPi. Subscriber Syntax for subscriber: sub = rospy . Subscriber ( '/topic_name' , msg_type , callback_fcn ) Example code: led_actuator.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #!/usr/bin/env python import rospy from std_msgs.msg import Bool import RPi.GPIO as GPIO # GPIO za LED: # Green 1 - GPIO 2 # Green 2 - GPIO 3 # Yellow 1 - GPIO 4 # Yellow 2 - GPIO 5 # Red 1 - GPIO 6 # Red 2 - GPIO 7 class rpi_led (): def __init__ ( self ): # init variables self . LED_GPIO = 7 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define subscriber # rospy.Subscriber('topic_name', varType, callback) self . sub = rospy . Subscriber ( '/button_state' , Bool , self . button_state_callback ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def button_state_callback ( self , msg ): # the code that is executed when data is received # turn on LED GPIO . output ( self . LED_GPIO , msg . data ) def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'led_actuator' ) # initialise class led_act = rpi_led () # reset leds led_act . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros led_actuator.py After that check topics (loook for /button_state ): rostopic list Use rostopic pub to turn LED on and off: rostopic pub /button_state std_msgs/Bool \"data: True\" rostopic pub /button_state std_msgs/Bool \"data: False\" To test both (publisher and subscriber), run each in the invidual terminal: rosrun rpi_feros button_publisher.py and rosrun rpi_feros led_actuator.py When pressing the button on RPi, the LED should turn on. DEBUG rostopic -h - rostopic help rostopic list - list of all active topics rostopic echo <topic name> - listen to selected topic -c - clear output each time -n2 - print only 2 outputs rostopic info <topic name> - information about topic rostopic pub <topic name> + Tab for autocomplete - publish data -1 - publish only once -r5 - publish with 5 Hz Exercise Turn on LED if the object is closer than 0.2 m. Roslaunch Roslaunch is a tool for easily launching multiple ROS nodes as well as setting parameters. Roslaunch takes in one or more XML configuration files (with the .launch extension) that specify the parameters to set and nodes to launch, as well as the machines that they should be run on. Basic sytax is <launch> <param name= \"/parameter_name\" type= \"variable_type\" value= \"variable_value\" /> <node name= \"name_of_the_node\" pkg= \"name_of_the_package\" type= \"source_file.py\" ns= \"namespace\" args= \"optional arguments\" /> <include file= \"included.launch\" > <arg name= \"arg_name\" value= \"arg_val\" /> </include> </launch> New .launch Create new package rpi_feros_bringup used for launch files: roscd cd .. cd src catkin_create_pkg rpi_feros_bringup and do catkin_make . Go the new package and create folder launch roscd rpi_feros_bringup mkdir launch cd launch Inside the folder create new file feros.launch touch rpi_led.launch code rpi_led.launch Copy the following lines rpi_led.launch 1 2 3 4 5 6 <?xml version=\"1.0\"?> <launch> <node name= \"btn_pub\" pkg= \"rpi_feros\" type= \"button_publisher.py\" output= \"screen\" /> <node name= \"led_act\" pkg= \"rpi_feros\" type= \"led_actuator.py\" output= \"screen\" /> </launch> To run the rpi_led.launch use roslaunch function roslaunch rpi_feros_bringup rpi_led.launch By running this .launch file three things are started roscore (automatically), button_publisher.py , and led_actuator.py . ROS network one ROS master in the entire network all nodes must use the same ROS master ( ROS_MASTER_URI ) two-way connection between devices each device must present itself with a name that other devices recognize http://wiki.ros.org/ROS/Tutorials/MultipleMachines http://wiki.ros.org/ROS/NetworkSetup Connection ping the remote computer (hostname: IP or name) ping 192.168.65.60 Use ssh to connect to remote computer and ping your computer ssh student@192.168.65.60 ping 192.168.65.50 ROS_MASTER_URI ROS master is set with variable ROS_MASTER_URI . It needs to be set withing each terminal. export ROS_MASTER_URI=http://[hostname]:11311 To check, use echo $ROS_MASTER_URI Set parameter ROS_IP for IP or ROS_HOSTNAME for hostname if you have multiple addresses for a computer and need to force ROS to a particular one. To do this automatically, add command to bashrc sudo nano ~/.bashrc Add export ROS_MASTER_URI=http://[hostname]:11311 ATTENTION! This can cause a problem, it you would like to run ROS master on the local computer. Test connection It is important to test connection in both ways: master (publisher) >>> others (subscriber) master (subscribers) <<< others (publisher) Publisher: rostopic pub /test_connection std_msgs/Bool \"data: True\" Subscriber: rostopic list rostopic echo /test_connection Exercise Connect to master computer with Sick Nanoscan3 and connect to topic /sick_safetyscanners/scan . Services Server/client system Synchronous operation For calculation and quick actions One message type for Request, another message type for Response A server is only one that can respond to multiple clients Example Turn on LED on button press using interrupts. Server Syntax for service server: service = rospy . Service ( '/service_name' , msg_type , handle_fcn ) Example code: led_service_server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/usr/bin/env python import rospy from std_srvs.srv import SetBool import RPi.GPIO as GPIO class ledServer (): def __init__ ( self ): # init variables self . LED_GPIO = 2 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define service # rospy.Service('service_name',varType,callback) rospy . Service ( '/set_led_state' , SetBool , self . set_led_status_callback ) rospy . loginfo ( \"Service server started. Ready to get request.\" ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def set_led_status_callback ( self , req ): # code that is executed when request is received # set LED to req.data GPIO . output ( self . LED_GPIO , req . data ) # server response return { 'success' : True , 'message' : 'Successfully changed LED state.' } def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'led_actuator' ) # initialise class led_server = ledServer () # reset leds led_server . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros led_service_server.py and check the list of services (look for /set_led_state ) rosservice list Use rosservice call to test the server rosservice call /set_led_state \"data: True\" rosservice call /set_led_state \"data: False\" Client Syntax for service proxy (client): 1 2 3 4 5 6 7 rospy . wait_for_service ( '/service_name' ) try : client = rospy . ServiceProxy ( '/service_name' , msg_type ) ... except rospy . ServiceException as e : rospy . logwarn ( 'Service failed' + str ( e )) Example: button_service_client.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python import rospy from std_srvs.srv import SetBool import RPi.GPIO as GPIO class buttonClient (): def __init__ ( self ): # init variables self . BUTTON_GPIO = 11 self . LED_STATE = False # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set button GPIO as input GPIO . setup ( self . BUTTON_GPIO , GPIO . IN ) # set interrupt # GPIO.add_event_detect(gpio_num, edge, callback, bouncetime) GPIO . add_event_detect ( self . BUTTON_GPIO , GPIO . RISING , callback = self . button_callback , bouncetime = 500 ) # define service proxy # rospy.ServiceProxy('service_name', varType) # wait for service rospy . wait_for_service ( '/set_led_state' ) # define proxy self . set_led_state = rospy . ServiceProxy ( '/set_led_state' , SetBool ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def button_callback ( self , channel ): # code that is called from interrupt # get the button state power_on_led = GPIO . input ( self . BUTTON_GPIO ) # change LED state self . LED_STATE = not self . LED_STATE try : # send request, get response resp = self . set_led_state ( self . LED_STATE ) # print response print ( resp ) except rospy . ServiceException as e : # in case of error rospy . logwarn ( e ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'button_monitor' ) # initialise class button_client = buttonClient () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test, run both server and client in seperate terminals rosrun rpi_feros led_service_server.py rosrun rpi_feros button_service_client.py With a button press, LED should turn on and off. DEBUG rosservice list - list of all active services rosservice info <service name> - information about the selected service rosservice call <service name> - request to service server from the console Exercise Use buttons to shift active LED left or right. Custom messages Topics messages: .msg Service messages: .srv Service message has two parts Request msg --- Response msg Use of msg primitives to define custom messages. MSG: std_msgs sensor_msgs geometry_msgs actionlib_msgs ... SRV: std_srvs ... MSG We will create new topic message ledStatus composed of int64 ledNumber string ledStatus Create new package rpi_msgs cd ~/catkin_ws/src catkin_create_pkg rpi_msgs rospy std_msgs and build it roscd cd .. catkin_make Go to the package and create new folder msg : roscd rpi_msgs mkdir msg cd msg Create new file ledStatus.msg touch ledStatus.msg code ledStatus.msg and copy the following lines: 1 2 int64 ledNumber string ledStatus Open package.xml in rpi_msgs package code package.xml and add the following lines package.xml 58 59 <build_depend> message_generation </build_depend> <exec_depend> message_runtime </exec_depend> Open CMakeLists.txt in rpi_msgs package code CMakeLists.txt and add the following lines CMakeLists.txt 10 11 12 13 14 find_package(catkin REQUIRED COMPONENTS rospy std_msgs message_generation ) CMakeLists.txt 49 50 51 52 53 # Generate messages in the 'msg' folder add_message_files( FILES ledStatus.msg ) CMakeLists.txt 69 70 71 72 73 # Generate added messages and services with any dependencies listed here generate_messages( DEPENDENCIES std_msgs ) CMakeLists.txt 104 105 106 107 108 109 catkin_package( # INCLUDE_DIRS include # LIBRARIES my_robot_msgs CATKIN_DEPENDS rospy std_msgs message_runtime # DEPENDS system_lib ) After that do catkin_make roscd cd .. catkin_make After the build is finish you can check if the message rpi_msgs/ledStatus is available rosmsg list |grep rpi SRV We will create new service message safetyZone.srv composed of int16 zone --- bool success string message Go to the package rpi_msgs roscd rpi_msgs and create new folder srv : mkdir srv cd msg Create new file safetyZone.srv touch safetyZone.srv code safetyZone.srv and copy the following lines: 1 2 3 4 int16 zone --- bool success string message Open CMakeLists.txt in rpi_msgs package code CMakeLists.txt and add the following lines CMakeLists.txt 55 56 57 58 59 # Generate services in the 'srv' folder add_service_files( FILES safetyZone.srv ) After that do the catkin_make roscd cd .. catkin_make After the build is finish you can check if the service message rpi_msgs/safetyZone is available rossrv list |grep rpi Use of custom MSG and SRV To use custom messages, you need to do some changes of the package.html and the CMakeLists.txt of the package where you want to use them (in our case rpi_feros ) package.html 61 <depend> rpi_msgs </depend> CMakeLists.txt 10 11 12 13 14 find_package(catkin REQUIRED COMPONENTS rospy std_msgs rpi_msgs ) To include new message in python code add 3 from rpi_msgs.msg import ledStatus , safetyZone DEBUG rosmsg list - list of available messages rosmsg show <msg name> - show message details rossrv list - list of available service messages rossrv show <srv msg name> - show service message details Exercise Turn on LEDs regarding to distance \\(d\\) from safety sensor: green: \\(d\\) > 0.4 m yellow: 0.4 m > \\(d\\) > 0.2 m red: \\(d\\) < 0.2 m Actions actionlib library server/client system asynchronous operation used for longer lasting functionalities you can perform other tasks while basic functionality is called action msg is composed of individual messages for Goal, Feedback and Result How to recognise action? Use rostopic list and look for the following structure ( as stands for action server ): as_name/cancel as_name/feedback as_name/goal as_name/result as_name/status ( as_name is action server namespace). Action MSG Action msgs can be defined in package rpi_msgs . Create new folder action and inside new file runningLed.action . roscd rpi_msgs mkdir action cd ./action touch runningLed.action code runnngLed.action Copy the following acton msg definition: runningLed.action 1 2 3 4 5 6 7 8 # goal int16 numberOfRuns --- # result int16 finalRun --- # feedback int16 currentRun In CMakeLists.txt of the rpi_msgs package change the following lines: CMakeLists.txt 10 11 12 13 14 15 find_package(catkin REQUIRED COMPONENTS rospy std_msgs message_generation actionlib_msgs ) CMakeLists.txt 62 63 64 65 add_action_files( FILES runningLed.action ) CMakeLists.txt 69 70 71 72 73 generate_messages( DEPENDENCIES std_msgs actionlib_msgs ) In package.xml of the rpi_msgs package add the following line: package.xml 60 <build_depend> actionlib_msgs </build_depend> Then do catkin_make in catkin_ws folder. Example Turn on sequential LEDs n-times. Action server Simple action server sytnax: 1 2 3 4 5 6 7 8 9 sas = actionlib . SimpleActionServer ( 'name' , actionSpec , goal_callback , auto_start = False ) sas . start () def goal_callback () sas . publish_feedback ( _feedback_ ) sas . set_succeeded ( _result_ ) if sas . is_preempt_requested (): sas . set_preempted () Example code for simple action server: ledrun_server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/usr/bin/env python import rospy import RPi.GPIO as GPIO # include actionlib import actionlib # include action msgs from rpi_msgs.msg import runningLedFeedback , runningLedResult , runningLedAction class runled_server (): def __init__ ( self ): # init variables # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define simple action server # actionlib.SimpleActionServer('action_name', actionType, callback, autostart) self . ACserver = actionlib . SimpleActionServer ( 'run_led' , runningLedAction , self . goal_callback , False ) # run server self . ACserver . start () print ( 'Server pripravljen' ) # define loop frequency (6 Hz) self . r = rospy . Rate ( 6 ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def goal_callback ( self , goal ): # Do lots of awesome groundbreaking robot stuff here self . resetLed () # print number of iterations print ( \"Stevilo iteracij: %i \" % goal . numberOfRuns ) # define feedback variable feedback1 = runningLedFeedback () # define result variable result1 = runningLedResult () success = True doPreemt = False # do number of iterations for kk in range ( 1 , goal . numberOfRuns + 1 ): # turn on individual LED (GPIO 2 - GPIO 7) for ii in range ( 2 , 8 ): # check if there was a preemt request if self . ACserver . is_preempt_requested (): # skip other interations print ( 'Goal preempted.' ) # definie result result1 . finalRun = kk # in case of preemt send result and text self . ACserver . set_preempted ( result = result1 , text = 'Goal preemted.' ) success = False doPreemt = True # break inside loop - turning on individual LEDs break ############################### # ACTIONS # clear all LED self . resetLed () # turn on LED i GPIO . output ( ii , True ) # 6 Hz self . r . sleep () ############################### # in case of preemt, break outside loop - iterations if doPreemt : break # send feedback after each interation feedback1 . currentRun = kk self . ACserver . publish_feedback ( feedback1 ) # send result after all iterations if success : # define results result1 . finalRun = feedback1 . currentRun # log rospy . loginfo ( 'Zakljuceno - Succeeded' ) # poslji rezultat self . ACserver . set_succeeded ( result1 ) def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'runled_server' ) # initialise class runled = runled_server () # reset leds runled . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass Action client Simple action client syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 client = actionlib . SimpleActionClient ( 'name' , actionSpec ) client . send_goal ( goal ) # Sends the goal to the action server. client . wait_for_result () # Waits for the server to finish performing the action. client . get_result () # Prints out the result of executing the action client . get_state () # Get current state of the server # define action server status PENDING = 0 ACTIVE = 1 DONE = 2 WARN = 3 ERROR = 4 Example code for simple action client: ledrun_client.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #!/usr/bin/env python import rospy # import actionlib import actionlib # import action msgs from rpi_msgs.msg import runningLedAction , runningLedGoal , runningLedResult # define action server status PENDING = 0 ACTIVE = 1 DONE = 2 WARN = 3 ERROR = 4 class runled_client (): def __init__ ( self ): # define simple action client # actionlib.SimpleActionClient('action:name', actionType) self . client = actionlib . SimpleActionClient ( 'run_led' , runningLedAction ) # wait, until server isnt active self . client . wait_for_server () rospy . loginfo ( \"Server is active.\" ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def run_led_client ( self , goalNum ): # define goal goal = runningLedGoal () goal . numberOfRuns = goalNum # send goal self . client . send_goal ( goal ) ''' ################################### # FOR PREEMT TESTING # after 3 s send new goal rospy.sleep(3) goal.numberOfRuns = 2 self.client.send_goal(goal) print('New goal was sent.') ################################### ''' # OPTION A - wait, until server doesn finish (similar to service) self . client . wait_for_result () ''' # OPTION B - do something else while you are waiting ## read current server state current_state = self.client.get_state() ## define loop frequency 1 Hz r2 = rospy.Rate(1) # until server status isnt DONE, do something else while current_state < DONE: # action is running, so do somethin productive # check state current_state = self.client.get_state() # 1 Hz r2.sleep() # is the server state is WARN if current_state == WARN: rospy.logwarn(\"Warning on the action server side.\") # if the server state is ERROR if current_state == ERROR: rospy.logerr(\"Error on the action server side.\") ''' # return result return self . client . get_result () def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'run_led_client' ) # initialise class runled = runled_client () try : # poslji goal result = runled . run_led_client ( goalNum = 10 ) # izpisi rezultat print ( \"Result: %i \" % result . finalRun ) except rospy . ROSInterruptException : # v primeru napake print ( \"Program interrupted before completion.\" ) Exercise Stop execution of LEDs sequential blinking if the object is closer that 20 cm. Parameters Parameter server: globally available dictionary within ROS master ROS parameter: one variable within the parameter server Types: Boolean Int Double String Lists ... Example Code examples: 1 2 3 4 5 6 7 8 9 10 11 # set parameter rospy . set_param ( '/publish_frequency' , 2 ) # get parameter publish_freq = rospy . get_param ( '/publish_frequency' ) # get list of parameters try : rospy . get_param_names () except ROSException : print ( \"Could not get param names\" ) Set parameter in a launch file: <param name= \"/parameter_name\" type= \"parameter_type\" value= \"value\" /> 1 2 3 <launch> <param name= \"/publish_frequency\" type= \"int\" value= \"2\" /> </launch> <rosparam> is used if you want to load a list of parameters from a .yaml file 1 <rosparam command= \"load\" file= \"$(find <package_name>)/example.yaml\" /> DEBUG rosparam set <param name> <value> - to create new parameter rosparam get <param name> - get parameter value rosparam list - get list of parameters Exercise Upgrade SimpleActionClient by setting number of runs as parameter /number_of_runs . Upgrade SimpleActionServer by setting LED frequency as parameter /led_frequency . Create .launch file for Action Server. ROS Debug tools Logging 5 logging levels: DEBUG INFO WARN ERROR FATAL Code example 1 2 3 4 5 6 7 8 rospy . init_node ( 'log_demo' , log_level = rospy . DEBUG ) while not rospy . is_shutdown (): rospy . logdebug ( \"Debug msg\" ) rospy . loginfo ( \"Info msg\" ) rospy . logwarn ( \"Warning msg\" ) rospy . logerr ( \"Error msg\" ) rospy . logfatal ( \"Fatal msg\" ) rqt_console GUI for log messages. rqt_console rqt_plot Graphical plot of signals from selected topics. rqt_plot rqt_graph Shows connection between nodes in the system. rqt_graph RViz RViz visually represents data from topics. RViz is NOT a simulation, it represents the current state of the robot rosrun rviz rviz","title":"Examples for RPi4"},{"location":"introduction/exampleRPI/#ros-setup","text":"","title":"ROS setup"},{"location":"introduction/exampleRPI/#roscore","text":"takes care of communicaiton between different ROS functionalities it can run only one at once connects different ROS system into one ROS network roscore","title":"roscore"},{"location":"introduction/exampleRPI/#catkin-workspace","text":"CATKIN is an official build system for ROS cd mkdir catkin_ws cd catkin_ws mkdir src catkin_make Alternative is to use catkin build (beforehand you need to remove devel and build folders). Conect console with ROS variables cd devel source setup.bash To do this automatically when the console is opened, add to bashrc.sh echo \"source ~/catkin_ws/devel/setup.bash\" >> ~/.bashrc source ~/.bashrc","title":"catkin workspace"},{"location":"introduction/exampleRPI/#packages","text":"Packages are independent units, that can be re-used.","title":"Packages"},{"location":"introduction/exampleRPI/#new-package","text":"Go to catkin_ws/src/ folder. Basic syntax: catkin_create_pkg <package_name> [depend1] [depend2] [depend3] Create new package rpi_test : cd ~/catkin_ws/src catkin_create_pkg rpi_test rospy std_msgs cd .. catkin_make","title":"New package"},{"location":"introduction/exampleRPI/#node","text":"Nodes are processes: used for calculations, that run inside robotic application, grouped into packages, that communicate with each other (topics, servers, actions, parameter servers). Why to use nodes: reduce code complexity, the code is more error-resistant, use of different programming languages.","title":"Node"},{"location":"introduction/exampleRPI/#new-node","text":"Nodes are scripts that are located inside scripts folder. roscd rpi_test mkdir scripts cd scripts Create new script my_first_node.py : touch my_first_node.py Change the access permissions of the file to executable: chmod +x my_first_node.py Open script with Visual Studio Code: code my_first_node.py The minimal working example for node: my_fist_node.py 1 2 3 4 5 6 7 8 9 #!/usr/bin/env python import rospy if __name__ == '__main__' : rospy . init_node ( 'my_first_python_node' ) rospy . loginfo ( 'This node has been started.' ) rospy . sleep ( 1 ) print ( 'Exit now' ) Only one node with specific name can be run at a time. If you want to run more instances of the same node, change: 6 rospy . init_node ( 'my_first_python_node' , anonymous = True ) To run, write python my_first_node.py","title":"New node"},{"location":"introduction/exampleRPI/#new-node-class","text":"my_fist_node_class.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/env python import rospy class hello_world (): def __init__ ( self ): # init variables self . delay = 5 self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c rospy . loginfo ( 'This node has been terminated.' ) self . ctrl_c = True def test_node ( self ): rospy . loginfo ( 'This node has been started.' ) rospy . sleep ( self . delay ) print ( 'Exit now' ) if __name__ == '__main__' : # initialise node rospy . init_node ( 'my_first_python_node' ) # initialise class first_node = hello_world () try : first_node . test_node () except rospy . ROSInterruptException : pass","title":"New node - class"},{"location":"introduction/exampleRPI/#debug","text":"rosrun <pkg name> <node name> - run specific node rosnode list - list of all active nodes rosnode info <node name> - information about hte node rosnode kill <node name> - shut down node rosnode ping <node name> - ping node (check, if it is working)","title":"DEBUG"},{"location":"introduction/exampleRPI/#examples-for-raspberry-pi","text":"Download examples on RaspberryPi. Go to src directory: roscd cd .. cd src Clone from GitHub: git clone https://github.com/ROS-FE/rpi_ros_examples.git . Build the packages: roscd cd .. catkin_make","title":"Examples for Raspberry Pi"},{"location":"introduction/exampleRPI/#topics","text":"Topic is: a communication channel through which nodes exchange messages one-way messaging (publisher> subscriber) anonymous topic has its own message type ( list of standars message types ) ROS master takes care of the proper publisher/subscriber connection each node can have multiple publishers/subscribers for different topics","title":"Topics"},{"location":"introduction/exampleRPI/#example","text":"Turn on LED on button press.","title":"Example"},{"location":"introduction/exampleRPI/#publisher","text":"Syntax for publisher: pub = rospy . Publisher ( '/topic_name' , msg_type , queue_size = 10 ) Example code: button_publisher.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #!/usr/bin/env python import rospy import RPi.GPIO as GPIO from std_msgs.msg import Bool # buttons GPIO pins # button 1 - gpio 11 # button 2 - gpio 12 class rpi_button (): def __init__ ( self ): # init variables self . BUTTON_GPIO = 11 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set button IO as input GPIO . setup ( self . BUTTON_GPIO , GPIO . IN ) # set loop frequency to 10 Hz self . rate = rospy . Rate ( 10 ) # define publisher # rospy.Publisher(\"topic_name\", varType, queue_size) self . pub = rospy . Publisher ( '/button_state' , Bool , queue_size = 10 ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def read_button ( self ): while not self . ctrl_c : # read GPIO pin gpio_state = GPIO . input ( self . BUTTON_GPIO ) # define msg as Bool variable self . msg = Bool () # msg has a data \"data\" self . msg . data = gpio_state # send msg self . publish_once () def publish_once ( self ): \"\"\" This is because publishing in topics sometimes fails the first time you publish. In continuous publishing systems, this is no big deal, but in systems that publish only once, it IS very important. \"\"\" while not self . ctrl_c : connections = self . pub . get_num_connections () if connections > 0 : self . pub . publish ( self . msg ) #rospy.loginfo(\"Msg Published\") break else : self . rate . sleep () def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all GPIO settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'button_state_publisher' , anonymous = True ) # initialise class btn = rpi_button () try : btn . read_button () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros button_publisher.py check the list of topics (look for /button_state ) rostopic list Then listen to that topic rostopic echo /button_state -c and press the button on RaspberryPi.","title":"Publisher"},{"location":"introduction/exampleRPI/#subscriber","text":"Syntax for subscriber: sub = rospy . Subscriber ( '/topic_name' , msg_type , callback_fcn ) Example code: led_actuator.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #!/usr/bin/env python import rospy from std_msgs.msg import Bool import RPi.GPIO as GPIO # GPIO za LED: # Green 1 - GPIO 2 # Green 2 - GPIO 3 # Yellow 1 - GPIO 4 # Yellow 2 - GPIO 5 # Red 1 - GPIO 6 # Red 2 - GPIO 7 class rpi_led (): def __init__ ( self ): # init variables self . LED_GPIO = 7 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define subscriber # rospy.Subscriber('topic_name', varType, callback) self . sub = rospy . Subscriber ( '/button_state' , Bool , self . button_state_callback ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def button_state_callback ( self , msg ): # the code that is executed when data is received # turn on LED GPIO . output ( self . LED_GPIO , msg . data ) def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'led_actuator' ) # initialise class led_act = rpi_led () # reset leds led_act . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros led_actuator.py After that check topics (loook for /button_state ): rostopic list Use rostopic pub to turn LED on and off: rostopic pub /button_state std_msgs/Bool \"data: True\" rostopic pub /button_state std_msgs/Bool \"data: False\" To test both (publisher and subscriber), run each in the invidual terminal: rosrun rpi_feros button_publisher.py and rosrun rpi_feros led_actuator.py When pressing the button on RPi, the LED should turn on.","title":"Subscriber"},{"location":"introduction/exampleRPI/#debug_1","text":"rostopic -h - rostopic help rostopic list - list of all active topics rostopic echo <topic name> - listen to selected topic -c - clear output each time -n2 - print only 2 outputs rostopic info <topic name> - information about topic rostopic pub <topic name> + Tab for autocomplete - publish data -1 - publish only once -r5 - publish with 5 Hz","title":"DEBUG"},{"location":"introduction/exampleRPI/#exercise","text":"Turn on LED if the object is closer than 0.2 m.","title":"Exercise"},{"location":"introduction/exampleRPI/#roslaunch","text":"Roslaunch is a tool for easily launching multiple ROS nodes as well as setting parameters. Roslaunch takes in one or more XML configuration files (with the .launch extension) that specify the parameters to set and nodes to launch, as well as the machines that they should be run on. Basic sytax is <launch> <param name= \"/parameter_name\" type= \"variable_type\" value= \"variable_value\" /> <node name= \"name_of_the_node\" pkg= \"name_of_the_package\" type= \"source_file.py\" ns= \"namespace\" args= \"optional arguments\" /> <include file= \"included.launch\" > <arg name= \"arg_name\" value= \"arg_val\" /> </include> </launch>","title":"Roslaunch"},{"location":"introduction/exampleRPI/#new-launch","text":"Create new package rpi_feros_bringup used for launch files: roscd cd .. cd src catkin_create_pkg rpi_feros_bringup and do catkin_make . Go the new package and create folder launch roscd rpi_feros_bringup mkdir launch cd launch Inside the folder create new file feros.launch touch rpi_led.launch code rpi_led.launch Copy the following lines rpi_led.launch 1 2 3 4 5 6 <?xml version=\"1.0\"?> <launch> <node name= \"btn_pub\" pkg= \"rpi_feros\" type= \"button_publisher.py\" output= \"screen\" /> <node name= \"led_act\" pkg= \"rpi_feros\" type= \"led_actuator.py\" output= \"screen\" /> </launch> To run the rpi_led.launch use roslaunch function roslaunch rpi_feros_bringup rpi_led.launch By running this .launch file three things are started roscore (automatically), button_publisher.py , and led_actuator.py .","title":"New .launch"},{"location":"introduction/exampleRPI/#ros-network","text":"one ROS master in the entire network all nodes must use the same ROS master ( ROS_MASTER_URI ) two-way connection between devices each device must present itself with a name that other devices recognize http://wiki.ros.org/ROS/Tutorials/MultipleMachines http://wiki.ros.org/ROS/NetworkSetup","title":"ROS network"},{"location":"introduction/exampleRPI/#connection","text":"ping the remote computer (hostname: IP or name) ping 192.168.65.60 Use ssh to connect to remote computer and ping your computer ssh student@192.168.65.60 ping 192.168.65.50","title":"Connection"},{"location":"introduction/exampleRPI/#ros_master_uri","text":"ROS master is set with variable ROS_MASTER_URI . It needs to be set withing each terminal. export ROS_MASTER_URI=http://[hostname]:11311 To check, use echo $ROS_MASTER_URI Set parameter ROS_IP for IP or ROS_HOSTNAME for hostname if you have multiple addresses for a computer and need to force ROS to a particular one. To do this automatically, add command to bashrc sudo nano ~/.bashrc Add export ROS_MASTER_URI=http://[hostname]:11311 ATTENTION! This can cause a problem, it you would like to run ROS master on the local computer.","title":"ROS_MASTER_URI"},{"location":"introduction/exampleRPI/#test-connection","text":"It is important to test connection in both ways: master (publisher) >>> others (subscriber) master (subscribers) <<< others (publisher) Publisher: rostopic pub /test_connection std_msgs/Bool \"data: True\" Subscriber: rostopic list rostopic echo /test_connection","title":"Test connection"},{"location":"introduction/exampleRPI/#exercise_1","text":"Connect to master computer with Sick Nanoscan3 and connect to topic /sick_safetyscanners/scan .","title":"Exercise"},{"location":"introduction/exampleRPI/#services","text":"Server/client system Synchronous operation For calculation and quick actions One message type for Request, another message type for Response A server is only one that can respond to multiple clients","title":"Services"},{"location":"introduction/exampleRPI/#example_1","text":"Turn on LED on button press using interrupts.","title":"Example"},{"location":"introduction/exampleRPI/#server","text":"Syntax for service server: service = rospy . Service ( '/service_name' , msg_type , handle_fcn ) Example code: led_service_server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/usr/bin/env python import rospy from std_srvs.srv import SetBool import RPi.GPIO as GPIO class ledServer (): def __init__ ( self ): # init variables self . LED_GPIO = 2 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define service # rospy.Service('service_name',varType,callback) rospy . Service ( '/set_led_state' , SetBool , self . set_led_status_callback ) rospy . loginfo ( \"Service server started. Ready to get request.\" ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def set_led_status_callback ( self , req ): # code that is executed when request is received # set LED to req.data GPIO . output ( self . LED_GPIO , req . data ) # server response return { 'success' : True , 'message' : 'Successfully changed LED state.' } def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'led_actuator' ) # initialise class led_server = ledServer () # reset leds led_server . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros led_service_server.py and check the list of services (look for /set_led_state ) rosservice list Use rosservice call to test the server rosservice call /set_led_state \"data: True\" rosservice call /set_led_state \"data: False\"","title":"Server"},{"location":"introduction/exampleRPI/#client","text":"Syntax for service proxy (client): 1 2 3 4 5 6 7 rospy . wait_for_service ( '/service_name' ) try : client = rospy . ServiceProxy ( '/service_name' , msg_type ) ... except rospy . ServiceException as e : rospy . logwarn ( 'Service failed' + str ( e )) Example: button_service_client.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python import rospy from std_srvs.srv import SetBool import RPi.GPIO as GPIO class buttonClient (): def __init__ ( self ): # init variables self . BUTTON_GPIO = 11 self . LED_STATE = False # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set button GPIO as input GPIO . setup ( self . BUTTON_GPIO , GPIO . IN ) # set interrupt # GPIO.add_event_detect(gpio_num, edge, callback, bouncetime) GPIO . add_event_detect ( self . BUTTON_GPIO , GPIO . RISING , callback = self . button_callback , bouncetime = 500 ) # define service proxy # rospy.ServiceProxy('service_name', varType) # wait for service rospy . wait_for_service ( '/set_led_state' ) # define proxy self . set_led_state = rospy . ServiceProxy ( '/set_led_state' , SetBool ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def button_callback ( self , channel ): # code that is called from interrupt # get the button state power_on_led = GPIO . input ( self . BUTTON_GPIO ) # change LED state self . LED_STATE = not self . LED_STATE try : # send request, get response resp = self . set_led_state ( self . LED_STATE ) # print response print ( resp ) except rospy . ServiceException as e : # in case of error rospy . logwarn ( e ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'button_monitor' ) # initialise class button_client = buttonClient () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test, run both server and client in seperate terminals rosrun rpi_feros led_service_server.py rosrun rpi_feros button_service_client.py With a button press, LED should turn on and off.","title":"Client"},{"location":"introduction/exampleRPI/#debug_2","text":"rosservice list - list of all active services rosservice info <service name> - information about the selected service rosservice call <service name> - request to service server from the console","title":"DEBUG"},{"location":"introduction/exampleRPI/#exercise_2","text":"Use buttons to shift active LED left or right.","title":"Exercise"},{"location":"introduction/exampleRPI/#custom-messages","text":"Topics messages: .msg Service messages: .srv Service message has two parts Request msg --- Response msg Use of msg primitives to define custom messages. MSG: std_msgs sensor_msgs geometry_msgs actionlib_msgs ... SRV: std_srvs ...","title":"Custom messages"},{"location":"introduction/exampleRPI/#msg","text":"We will create new topic message ledStatus composed of int64 ledNumber string ledStatus Create new package rpi_msgs cd ~/catkin_ws/src catkin_create_pkg rpi_msgs rospy std_msgs and build it roscd cd .. catkin_make Go to the package and create new folder msg : roscd rpi_msgs mkdir msg cd msg Create new file ledStatus.msg touch ledStatus.msg code ledStatus.msg and copy the following lines: 1 2 int64 ledNumber string ledStatus Open package.xml in rpi_msgs package code package.xml and add the following lines package.xml 58 59 <build_depend> message_generation </build_depend> <exec_depend> message_runtime </exec_depend> Open CMakeLists.txt in rpi_msgs package code CMakeLists.txt and add the following lines CMakeLists.txt 10 11 12 13 14 find_package(catkin REQUIRED COMPONENTS rospy std_msgs message_generation ) CMakeLists.txt 49 50 51 52 53 # Generate messages in the 'msg' folder add_message_files( FILES ledStatus.msg ) CMakeLists.txt 69 70 71 72 73 # Generate added messages and services with any dependencies listed here generate_messages( DEPENDENCIES std_msgs ) CMakeLists.txt 104 105 106 107 108 109 catkin_package( # INCLUDE_DIRS include # LIBRARIES my_robot_msgs CATKIN_DEPENDS rospy std_msgs message_runtime # DEPENDS system_lib ) After that do catkin_make roscd cd .. catkin_make After the build is finish you can check if the message rpi_msgs/ledStatus is available rosmsg list |grep rpi","title":"MSG"},{"location":"introduction/exampleRPI/#srv","text":"We will create new service message safetyZone.srv composed of int16 zone --- bool success string message Go to the package rpi_msgs roscd rpi_msgs and create new folder srv : mkdir srv cd msg Create new file safetyZone.srv touch safetyZone.srv code safetyZone.srv and copy the following lines: 1 2 3 4 int16 zone --- bool success string message Open CMakeLists.txt in rpi_msgs package code CMakeLists.txt and add the following lines CMakeLists.txt 55 56 57 58 59 # Generate services in the 'srv' folder add_service_files( FILES safetyZone.srv ) After that do the catkin_make roscd cd .. catkin_make After the build is finish you can check if the service message rpi_msgs/safetyZone is available rossrv list |grep rpi","title":"SRV"},{"location":"introduction/exampleRPI/#use-of-custom-msg-and-srv","text":"To use custom messages, you need to do some changes of the package.html and the CMakeLists.txt of the package where you want to use them (in our case rpi_feros ) package.html 61 <depend> rpi_msgs </depend> CMakeLists.txt 10 11 12 13 14 find_package(catkin REQUIRED COMPONENTS rospy std_msgs rpi_msgs ) To include new message in python code add 3 from rpi_msgs.msg import ledStatus , safetyZone","title":"Use of custom MSG and SRV"},{"location":"introduction/exampleRPI/#debug_3","text":"rosmsg list - list of available messages rosmsg show <msg name> - show message details rossrv list - list of available service messages rossrv show <srv msg name> - show service message details","title":"DEBUG"},{"location":"introduction/exampleRPI/#exercise_3","text":"Turn on LEDs regarding to distance \\(d\\) from safety sensor: green: \\(d\\) > 0.4 m yellow: 0.4 m > \\(d\\) > 0.2 m red: \\(d\\) < 0.2 m","title":"Exercise"},{"location":"introduction/exampleRPI/#actions","text":"actionlib library server/client system asynchronous operation used for longer lasting functionalities you can perform other tasks while basic functionality is called action msg is composed of individual messages for Goal, Feedback and Result How to recognise action? Use rostopic list and look for the following structure ( as stands for action server ): as_name/cancel as_name/feedback as_name/goal as_name/result as_name/status ( as_name is action server namespace).","title":"Actions"},{"location":"introduction/exampleRPI/#action-msg","text":"Action msgs can be defined in package rpi_msgs . Create new folder action and inside new file runningLed.action . roscd rpi_msgs mkdir action cd ./action touch runningLed.action code runnngLed.action Copy the following acton msg definition: runningLed.action 1 2 3 4 5 6 7 8 # goal int16 numberOfRuns --- # result int16 finalRun --- # feedback int16 currentRun In CMakeLists.txt of the rpi_msgs package change the following lines: CMakeLists.txt 10 11 12 13 14 15 find_package(catkin REQUIRED COMPONENTS rospy std_msgs message_generation actionlib_msgs ) CMakeLists.txt 62 63 64 65 add_action_files( FILES runningLed.action ) CMakeLists.txt 69 70 71 72 73 generate_messages( DEPENDENCIES std_msgs actionlib_msgs ) In package.xml of the rpi_msgs package add the following line: package.xml 60 <build_depend> actionlib_msgs </build_depend> Then do catkin_make in catkin_ws folder.","title":"Action MSG"},{"location":"introduction/exampleRPI/#example_2","text":"Turn on sequential LEDs n-times.","title":"Example"},{"location":"introduction/exampleRPI/#action-server","text":"Simple action server sytnax: 1 2 3 4 5 6 7 8 9 sas = actionlib . SimpleActionServer ( 'name' , actionSpec , goal_callback , auto_start = False ) sas . start () def goal_callback () sas . publish_feedback ( _feedback_ ) sas . set_succeeded ( _result_ ) if sas . is_preempt_requested (): sas . set_preempted () Example code for simple action server: ledrun_server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/usr/bin/env python import rospy import RPi.GPIO as GPIO # include actionlib import actionlib # include action msgs from rpi_msgs.msg import runningLedFeedback , runningLedResult , runningLedAction class runled_server (): def __init__ ( self ): # init variables # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define simple action server # actionlib.SimpleActionServer('action_name', actionType, callback, autostart) self . ACserver = actionlib . SimpleActionServer ( 'run_led' , runningLedAction , self . goal_callback , False ) # run server self . ACserver . start () print ( 'Server pripravljen' ) # define loop frequency (6 Hz) self . r = rospy . Rate ( 6 ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def goal_callback ( self , goal ): # Do lots of awesome groundbreaking robot stuff here self . resetLed () # print number of iterations print ( \"Stevilo iteracij: %i \" % goal . numberOfRuns ) # define feedback variable feedback1 = runningLedFeedback () # define result variable result1 = runningLedResult () success = True doPreemt = False # do number of iterations for kk in range ( 1 , goal . numberOfRuns + 1 ): # turn on individual LED (GPIO 2 - GPIO 7) for ii in range ( 2 , 8 ): # check if there was a preemt request if self . ACserver . is_preempt_requested (): # skip other interations print ( 'Goal preempted.' ) # definie result result1 . finalRun = kk # in case of preemt send result and text self . ACserver . set_preempted ( result = result1 , text = 'Goal preemted.' ) success = False doPreemt = True # break inside loop - turning on individual LEDs break ############################### # ACTIONS # clear all LED self . resetLed () # turn on LED i GPIO . output ( ii , True ) # 6 Hz self . r . sleep () ############################### # in case of preemt, break outside loop - iterations if doPreemt : break # send feedback after each interation feedback1 . currentRun = kk self . ACserver . publish_feedback ( feedback1 ) # send result after all iterations if success : # define results result1 . finalRun = feedback1 . currentRun # log rospy . loginfo ( 'Zakljuceno - Succeeded' ) # poslji rezultat self . ACserver . set_succeeded ( result1 ) def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'runled_server' ) # initialise class runled = runled_server () # reset leds runled . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass","title":"Action server"},{"location":"introduction/exampleRPI/#action-client","text":"Simple action client syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 client = actionlib . SimpleActionClient ( 'name' , actionSpec ) client . send_goal ( goal ) # Sends the goal to the action server. client . wait_for_result () # Waits for the server to finish performing the action. client . get_result () # Prints out the result of executing the action client . get_state () # Get current state of the server # define action server status PENDING = 0 ACTIVE = 1 DONE = 2 WARN = 3 ERROR = 4 Example code for simple action client: ledrun_client.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #!/usr/bin/env python import rospy # import actionlib import actionlib # import action msgs from rpi_msgs.msg import runningLedAction , runningLedGoal , runningLedResult # define action server status PENDING = 0 ACTIVE = 1 DONE = 2 WARN = 3 ERROR = 4 class runled_client (): def __init__ ( self ): # define simple action client # actionlib.SimpleActionClient('action:name', actionType) self . client = actionlib . SimpleActionClient ( 'run_led' , runningLedAction ) # wait, until server isnt active self . client . wait_for_server () rospy . loginfo ( \"Server is active.\" ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def run_led_client ( self , goalNum ): # define goal goal = runningLedGoal () goal . numberOfRuns = goalNum # send goal self . client . send_goal ( goal ) ''' ################################### # FOR PREEMT TESTING # after 3 s send new goal rospy.sleep(3) goal.numberOfRuns = 2 self.client.send_goal(goal) print('New goal was sent.') ################################### ''' # OPTION A - wait, until server doesn finish (similar to service) self . client . wait_for_result () ''' # OPTION B - do something else while you are waiting ## read current server state current_state = self.client.get_state() ## define loop frequency 1 Hz r2 = rospy.Rate(1) # until server status isnt DONE, do something else while current_state < DONE: # action is running, so do somethin productive # check state current_state = self.client.get_state() # 1 Hz r2.sleep() # is the server state is WARN if current_state == WARN: rospy.logwarn(\"Warning on the action server side.\") # if the server state is ERROR if current_state == ERROR: rospy.logerr(\"Error on the action server side.\") ''' # return result return self . client . get_result () def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'run_led_client' ) # initialise class runled = runled_client () try : # poslji goal result = runled . run_led_client ( goalNum = 10 ) # izpisi rezultat print ( \"Result: %i \" % result . finalRun ) except rospy . ROSInterruptException : # v primeru napake print ( \"Program interrupted before completion.\" )","title":"Action client"},{"location":"introduction/exampleRPI/#exercise_4","text":"Stop execution of LEDs sequential blinking if the object is closer that 20 cm.","title":"Exercise"},{"location":"introduction/exampleRPI/#parameters","text":"Parameter server: globally available dictionary within ROS master ROS parameter: one variable within the parameter server Types: Boolean Int Double String Lists ...","title":"Parameters"},{"location":"introduction/exampleRPI/#example_3","text":"Code examples: 1 2 3 4 5 6 7 8 9 10 11 # set parameter rospy . set_param ( '/publish_frequency' , 2 ) # get parameter publish_freq = rospy . get_param ( '/publish_frequency' ) # get list of parameters try : rospy . get_param_names () except ROSException : print ( \"Could not get param names\" ) Set parameter in a launch file: <param name= \"/parameter_name\" type= \"parameter_type\" value= \"value\" /> 1 2 3 <launch> <param name= \"/publish_frequency\" type= \"int\" value= \"2\" /> </launch> <rosparam> is used if you want to load a list of parameters from a .yaml file 1 <rosparam command= \"load\" file= \"$(find <package_name>)/example.yaml\" />","title":"Example"},{"location":"introduction/exampleRPI/#debug_4","text":"rosparam set <param name> <value> - to create new parameter rosparam get <param name> - get parameter value rosparam list - get list of parameters","title":"DEBUG"},{"location":"introduction/exampleRPI/#exercise_5","text":"Upgrade SimpleActionClient by setting number of runs as parameter /number_of_runs . Upgrade SimpleActionServer by setting LED frequency as parameter /led_frequency . Create .launch file for Action Server.","title":"Exercise"},{"location":"introduction/exampleRPI/#ros-debug-tools","text":"","title":"ROS Debug tools"},{"location":"introduction/exampleRPI/#logging","text":"5 logging levels: DEBUG INFO WARN ERROR FATAL Code example 1 2 3 4 5 6 7 8 rospy . init_node ( 'log_demo' , log_level = rospy . DEBUG ) while not rospy . is_shutdown (): rospy . logdebug ( \"Debug msg\" ) rospy . loginfo ( \"Info msg\" ) rospy . logwarn ( \"Warning msg\" ) rospy . logerr ( \"Error msg\" ) rospy . logfatal ( \"Fatal msg\" )","title":"Logging"},{"location":"introduction/exampleRPI/#rqt_console","text":"GUI for log messages. rqt_console","title":"rqt_console"},{"location":"introduction/exampleRPI/#rqt_plot","text":"Graphical plot of signals from selected topics. rqt_plot","title":"rqt_plot"},{"location":"introduction/exampleRPI/#rqt_graph","text":"Shows connection between nodes in the system. rqt_graph","title":"rqt_graph"},{"location":"introduction/exampleRPI/#rviz","text":"RViz visually represents data from topics. RViz is NOT a simulation, it represents the current state of the robot rosrun rviz rviz","title":"RViz"},{"location":"introduction/launch/","text":"Roslaunch Roslaunch is a tool for easily launching multiple ROS nodes as well as setting parameters. Roslaunch takes in one or more XML configuration files (with the .launch extension) that specify the parameters to set and nodes to launch, as well as the machines that they should be run on. Basic sytax is <launch> <param name= \"/parameter_name\" type= \"variable_type\" value= \"variable_value\" /> <node name= \"name_of_the_node\" pkg= \"name_of_the_package\" type= \"source_file.py\" ns= \"namespace\" args= \"optional arguments\" /> <include file= \"included.launch\" > <arg name= \"arg_name\" value= \"arg_val\" /> </include> </launch> New .launch Create new package rpi_feros_bringup used for launch files: roscd cd .. cd src catkin_create_pkg rpi_feros_bringup and do catkin_make . Go the new package and create folder launch roscd rpi_feros_bringup mkdir launch cd launch Inside the folder create new file feros.launch touch rpi_led.launch code rpi_led.launch Copy the following lines rpi_led.launch 1 2 3 4 5 6 <?xml version=\"1.0\"?> <launch> <node name= \"btn_pub\" pkg= \"rpi_feros\" type= \"button_publisher.py\" output= \"screen\" /> <node name= \"led_act\" pkg= \"rpi_feros\" type= \"led_actuator.py\" output= \"screen\" /> </launch> To run the rpi_led.launch use roslaunch function roslaunch rpi_feros_bringup rpi_led.launch By running this .launch file three things are started roscore (automatically), button_publisher.py , and led_actuator.py .","title":"Launch file"},{"location":"introduction/launch/#roslaunch","text":"Roslaunch is a tool for easily launching multiple ROS nodes as well as setting parameters. Roslaunch takes in one or more XML configuration files (with the .launch extension) that specify the parameters to set and nodes to launch, as well as the machines that they should be run on. Basic sytax is <launch> <param name= \"/parameter_name\" type= \"variable_type\" value= \"variable_value\" /> <node name= \"name_of_the_node\" pkg= \"name_of_the_package\" type= \"source_file.py\" ns= \"namespace\" args= \"optional arguments\" /> <include file= \"included.launch\" > <arg name= \"arg_name\" value= \"arg_val\" /> </include> </launch>","title":"Roslaunch"},{"location":"introduction/launch/#new-launch","text":"Create new package rpi_feros_bringup used for launch files: roscd cd .. cd src catkin_create_pkg rpi_feros_bringup and do catkin_make . Go the new package and create folder launch roscd rpi_feros_bringup mkdir launch cd launch Inside the folder create new file feros.launch touch rpi_led.launch code rpi_led.launch Copy the following lines rpi_led.launch 1 2 3 4 5 6 <?xml version=\"1.0\"?> <launch> <node name= \"btn_pub\" pkg= \"rpi_feros\" type= \"button_publisher.py\" output= \"screen\" /> <node name= \"led_act\" pkg= \"rpi_feros\" type= \"led_actuator.py\" output= \"screen\" /> </launch> To run the rpi_led.launch use roslaunch function roslaunch rpi_feros_bringup rpi_led.launch By running this .launch file three things are started roscore (automatically), button_publisher.py , and led_actuator.py .","title":"New .launch"},{"location":"introduction/msg/","text":"Custom messages Topics messages: .msg Service messages: .srv Service message has two parts Request msg --- Response msg Use of msg primitives to define custom messages. MSG: std_msgs sensor_msgs geometry_msgs actionlib_msgs ... SRV: std_srvs ... MSG We will create new topic message ledStatus composed of int64 ledNumber string ledStatus Create new package rpi_msgs cd ~/catkin_ws/src catkin_create_pkg rpi_msgs rospy std_msgs and build it roscd cd .. catkin_make Go to the package and create new folder msg : roscd rpi_msgs mkdir msg cd msg Create new file ledStatus.msg touch ledStatus.msg code ledStatus.msg and copy the following lines: 1 2 int64 ledNumber string ledStatus Open package.xml in rpi_msgs package code package.xml and add the following lines package.xml 58 59 <build_depend> message_generation </build_depend> <exec_depend> message_runtime </exec_depend> Open CMakeLists.txt in rpi_msgs package code CMakeLists.txt and add the following lines CMakeLists.txt 10 11 12 13 14 find_package(catkin REQUIRED COMPONENTS rospy std_msgs message_generation ) CMakeLists.txt 49 50 51 52 53 # Generate messages in the 'msg' folder add_message_files( FILES ledStatus.msg ) CMakeLists.txt 69 70 71 72 73 # Generate added messages and services with any dependencies listed here generate_messages( DEPENDENCIES std_msgs ) CMakeLists.txt 104 105 106 107 108 109 catkin_package( # INCLUDE_DIRS include # LIBRARIES my_robot_msgs CATKIN_DEPENDS rospy std_msgs message_runtime # DEPENDS system_lib ) After that do catkin_make roscd cd .. catkin_make After the build is finish you can check if the message rpi_msgs/ledStatus is available rosmsg list |grep rpi SRV We will create new service message safetyZone.srv composed of int16 zone --- bool success string message Go to the package rpi_msgs roscd rpi_msgs and create new folder srv : mkdir srv cd msg Create new file safetyZone.srv touch safetyZone.srv code safetyZone.srv and copy the following lines: 1 2 3 4 int16 zone --- bool success string message Open CMakeLists.txt in rpi_msgs package code CMakeLists.txt and add the following lines CMakeLists.txt 55 56 57 58 59 # Generate services in the 'srv' folder add_service_files( FILES safetyZone.srv ) After that do the catkin_make roscd cd .. catkin_make After the build is finish you can check if the service message rpi_msgs/safetyZone is available rossrv list |grep rpi Use of custom MSG and SRV To use custom messages, you need to do some changes of the package.html and the CMakeLists.txt of the package where you want to use them (in our case rpi_feros ) package.html 61 <depend> rpi_msgs </depend> CMakeLists.txt 10 11 12 13 14 find_package(catkin REQUIRED COMPONENTS rospy std_msgs rpi_msgs ) To include new message in python code add 3 from rpi_msgs.msg import ledStatus , safetyZone DEBUG rosmsg list - list of available messages rosmsg show <msg name> - show message details rossrv list - list of available service messages rossrv show <srv msg name> - show service message details Exercise Turn on LEDs regarding to distance \\(d\\) from safety sensor: green: \\(d\\) > 0.4 m yellow: 0.4 m > \\(d\\) > 0.2 m red: \\(d\\) < 0.2 m","title":"Custom messages"},{"location":"introduction/msg/#custom-messages","text":"Topics messages: .msg Service messages: .srv Service message has two parts Request msg --- Response msg Use of msg primitives to define custom messages. MSG: std_msgs sensor_msgs geometry_msgs actionlib_msgs ... SRV: std_srvs ...","title":"Custom messages"},{"location":"introduction/msg/#msg","text":"We will create new topic message ledStatus composed of int64 ledNumber string ledStatus Create new package rpi_msgs cd ~/catkin_ws/src catkin_create_pkg rpi_msgs rospy std_msgs and build it roscd cd .. catkin_make Go to the package and create new folder msg : roscd rpi_msgs mkdir msg cd msg Create new file ledStatus.msg touch ledStatus.msg code ledStatus.msg and copy the following lines: 1 2 int64 ledNumber string ledStatus Open package.xml in rpi_msgs package code package.xml and add the following lines package.xml 58 59 <build_depend> message_generation </build_depend> <exec_depend> message_runtime </exec_depend> Open CMakeLists.txt in rpi_msgs package code CMakeLists.txt and add the following lines CMakeLists.txt 10 11 12 13 14 find_package(catkin REQUIRED COMPONENTS rospy std_msgs message_generation ) CMakeLists.txt 49 50 51 52 53 # Generate messages in the 'msg' folder add_message_files( FILES ledStatus.msg ) CMakeLists.txt 69 70 71 72 73 # Generate added messages and services with any dependencies listed here generate_messages( DEPENDENCIES std_msgs ) CMakeLists.txt 104 105 106 107 108 109 catkin_package( # INCLUDE_DIRS include # LIBRARIES my_robot_msgs CATKIN_DEPENDS rospy std_msgs message_runtime # DEPENDS system_lib ) After that do catkin_make roscd cd .. catkin_make After the build is finish you can check if the message rpi_msgs/ledStatus is available rosmsg list |grep rpi","title":"MSG"},{"location":"introduction/msg/#srv","text":"We will create new service message safetyZone.srv composed of int16 zone --- bool success string message Go to the package rpi_msgs roscd rpi_msgs and create new folder srv : mkdir srv cd msg Create new file safetyZone.srv touch safetyZone.srv code safetyZone.srv and copy the following lines: 1 2 3 4 int16 zone --- bool success string message Open CMakeLists.txt in rpi_msgs package code CMakeLists.txt and add the following lines CMakeLists.txt 55 56 57 58 59 # Generate services in the 'srv' folder add_service_files( FILES safetyZone.srv ) After that do the catkin_make roscd cd .. catkin_make After the build is finish you can check if the service message rpi_msgs/safetyZone is available rossrv list |grep rpi","title":"SRV"},{"location":"introduction/msg/#use-of-custom-msg-and-srv","text":"To use custom messages, you need to do some changes of the package.html and the CMakeLists.txt of the package where you want to use them (in our case rpi_feros ) package.html 61 <depend> rpi_msgs </depend> CMakeLists.txt 10 11 12 13 14 find_package(catkin REQUIRED COMPONENTS rospy std_msgs rpi_msgs ) To include new message in python code add 3 from rpi_msgs.msg import ledStatus , safetyZone","title":"Use of custom MSG and SRV"},{"location":"introduction/msg/#debug","text":"rosmsg list - list of available messages rosmsg show <msg name> - show message details rossrv list - list of available service messages rossrv show <srv msg name> - show service message details","title":"DEBUG"},{"location":"introduction/msg/#exercise","text":"Turn on LEDs regarding to distance \\(d\\) from safety sensor: green: \\(d\\) > 0.4 m yellow: 0.4 m > \\(d\\) > 0.2 m red: \\(d\\) < 0.2 m","title":"Exercise"},{"location":"introduction/network/","text":"ROS network one ROS master in the entire network all nodes must use the same ROS master ( ROS_MASTER_URI ) two-way connection between devices each device must present itself with a name that other devices recognize http://wiki.ros.org/ROS/Tutorials/MultipleMachines http://wiki.ros.org/ROS/NetworkSetup Connection ping the remote computer (hostname: IP or name) ping 192.168.65.60 Use ssh to connect to remote computer and ping your computer ssh student@192.168.65.60 ping 192.168.65.50 ROS_MASTER_URI ROS master is set with variable ROS_MASTER_URI . It needs to be set withing each terminal. export ROS_MASTER_URI=http://[hostname]:11311 To check, use echo $ROS_MASTER_URI Set parameter ROS_IP for IP or ROS_HOSTNAME for hostname if you have multiple addresses for a computer and need to force ROS to a particular one. To do this automatically, add command to bashrc sudo nano ~/.bashrc Add export ROS_MASTER_URI=http://[hostname]:11311 ATTENTION! This can cause a problem, it you would like to run ROS master on the local computer. Test connection It is important to test connection in both ways: master (publisher) >>> others (subscriber) master (subscribers) <<< others (publisher) Publisher: rostopic pub /test_connection std_msgs/Bool \"data: True\" Subscriber: rostopic list rostopic echo /test_connection Exercise Connect to master computer with Sick Nanoscan3 and connect to topic /sick_safetyscanners/scan .","title":"ROS Network"},{"location":"introduction/network/#ros-network","text":"one ROS master in the entire network all nodes must use the same ROS master ( ROS_MASTER_URI ) two-way connection between devices each device must present itself with a name that other devices recognize http://wiki.ros.org/ROS/Tutorials/MultipleMachines http://wiki.ros.org/ROS/NetworkSetup","title":"ROS network"},{"location":"introduction/network/#connection","text":"ping the remote computer (hostname: IP or name) ping 192.168.65.60 Use ssh to connect to remote computer and ping your computer ssh student@192.168.65.60 ping 192.168.65.50","title":"Connection"},{"location":"introduction/network/#ros_master_uri","text":"ROS master is set with variable ROS_MASTER_URI . It needs to be set withing each terminal. export ROS_MASTER_URI=http://[hostname]:11311 To check, use echo $ROS_MASTER_URI Set parameter ROS_IP for IP or ROS_HOSTNAME for hostname if you have multiple addresses for a computer and need to force ROS to a particular one. To do this automatically, add command to bashrc sudo nano ~/.bashrc Add export ROS_MASTER_URI=http://[hostname]:11311 ATTENTION! This can cause a problem, it you would like to run ROS master on the local computer.","title":"ROS_MASTER_URI"},{"location":"introduction/network/#test-connection","text":"It is important to test connection in both ways: master (publisher) >>> others (subscriber) master (subscribers) <<< others (publisher) Publisher: rostopic pub /test_connection std_msgs/Bool \"data: True\" Subscriber: rostopic list rostopic echo /test_connection","title":"Test connection"},{"location":"introduction/network/#exercise","text":"Connect to master computer with Sick Nanoscan3 and connect to topic /sick_safetyscanners/scan .","title":"Exercise"},{"location":"introduction/nodes/","text":"Node Nodes are processes: used for calculations, that run inside robotic application, grouped into packages, that communicate with each other (topics, servers, actions, parameter servers). Why to use nodes: reduce code complexity, the code is more error-resistant, use of different programming languages. New node Nodes are scripts that are located inside scripts folder. roscd rpi_test mkdir scripts cd scripts Create new script my_first_node.py : touch my_first_node.py Change the access permissions of the file to executable: chmod +x my_first_node.py Open script with Visual Studio Code: code my_first_node.py The minimal working example for node: my_fist_node.py 1 2 3 4 5 6 7 8 9 #!/usr/bin/env python import rospy if __name__ == '__main__' : rospy . init_node ( 'my_first_python_node' ) rospy . loginfo ( 'This node has been started.' ) rospy . sleep ( 1 ) print ( 'Exit now' ) Only one node with specific name can be run at a time. If you want to run more instances of the same node, change: 6 rospy . init_node ( 'my_first_python_node' , anonymous = True ) To run, write python my_first_node.py New node - class my_fist_node_class.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/env python import rospy class hello_world (): def __init__ ( self ): # init variables self . delay = 5 self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c rospy . loginfo ( 'This node has been terminated.' ) self . ctrl_c = True def test_node ( self ): rospy . loginfo ( 'This node has been started.' ) rospy . sleep ( self . delay ) print ( 'Exit now' ) if __name__ == '__main__' : # initialise node rospy . init_node ( 'my_first_python_node' ) # initialise class first_node = hello_world () try : first_node . test_node () except rospy . ROSInterruptException : pass DEBUG rosrun <pkg name> <node name> - run specific node rosnode list - list of all active nodes rosnode info <node name> - information about hte node rosnode kill <node name> - shut down node rosnode ping <node name> - ping node (check, if it is working)","title":"Node"},{"location":"introduction/nodes/#node","text":"Nodes are processes: used for calculations, that run inside robotic application, grouped into packages, that communicate with each other (topics, servers, actions, parameter servers). Why to use nodes: reduce code complexity, the code is more error-resistant, use of different programming languages.","title":"Node"},{"location":"introduction/nodes/#new-node","text":"Nodes are scripts that are located inside scripts folder. roscd rpi_test mkdir scripts cd scripts Create new script my_first_node.py : touch my_first_node.py Change the access permissions of the file to executable: chmod +x my_first_node.py Open script with Visual Studio Code: code my_first_node.py The minimal working example for node: my_fist_node.py 1 2 3 4 5 6 7 8 9 #!/usr/bin/env python import rospy if __name__ == '__main__' : rospy . init_node ( 'my_first_python_node' ) rospy . loginfo ( 'This node has been started.' ) rospy . sleep ( 1 ) print ( 'Exit now' ) Only one node with specific name can be run at a time. If you want to run more instances of the same node, change: 6 rospy . init_node ( 'my_first_python_node' , anonymous = True ) To run, write python my_first_node.py","title":"New node"},{"location":"introduction/nodes/#new-node-class","text":"my_fist_node_class.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/env python import rospy class hello_world (): def __init__ ( self ): # init variables self . delay = 5 self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c rospy . loginfo ( 'This node has been terminated.' ) self . ctrl_c = True def test_node ( self ): rospy . loginfo ( 'This node has been started.' ) rospy . sleep ( self . delay ) print ( 'Exit now' ) if __name__ == '__main__' : # initialise node rospy . init_node ( 'my_first_python_node' ) # initialise class first_node = hello_world () try : first_node . test_node () except rospy . ROSInterruptException : pass","title":"New node - class"},{"location":"introduction/nodes/#debug","text":"rosrun <pkg name> <node name> - run specific node rosnode list - list of all active nodes rosnode info <node name> - information about hte node rosnode kill <node name> - shut down node rosnode ping <node name> - ping node (check, if it is working)","title":"DEBUG"},{"location":"introduction/packages/","text":"Packages Packages are independent units, that can be re-used. New package Go to catkin_ws/src/ folder. Basic syntax: catkin_create_pkg <package_name> [depend1] [depend2] [depend3] Create new package rpi_test : cd ~/catkin_ws/src catkin_create_pkg rpi_test rospy std_msgs cd .. catkin_make","title":"Packages"},{"location":"introduction/packages/#packages","text":"Packages are independent units, that can be re-used.","title":"Packages"},{"location":"introduction/packages/#new-package","text":"Go to catkin_ws/src/ folder. Basic syntax: catkin_create_pkg <package_name> [depend1] [depend2] [depend3] Create new package rpi_test : cd ~/catkin_ws/src catkin_create_pkg rpi_test rospy std_msgs cd .. catkin_make","title":"New package"},{"location":"introduction/parameters/","text":"Parameters Parameter server: globally available dictionary within ROS master ROS parameter: one variable within the parameter server Types: Boolean Int Double String Lists ... Example Code examples: 1 2 3 4 5 6 7 8 9 10 11 # set parameter rospy . set_param ( '/publish_frequency' , 2 ) # get parameter publish_freq = rospy . get_param ( '/publish_frequency' ) # get list of parameters try : rospy . get_param_names () except ROSException : print ( \"Could not get param names\" ) Set parameter in a launch file: <param name= \"/parameter_name\" type= \"parameter_type\" value= \"value\" /> 1 2 3 <launch> <param name= \"/publish_frequency\" type= \"int\" value= \"2\" /> </launch> <rosparam> is used if you want to load a list of parameters from a .yaml file 1 <rosparam command= \"load\" file= \"$(find <package_name>)/example.yaml\" /> DEBUG rosparam set <param name> <value> - to create new parameter rosparam get <param name> - get parameter value rosparam list - get list of parameters Exercise Upgrade SimpleActionClient by setting number of runs as parameter /number_of_runs . Upgrade SimpleActionServer by setting LED frequency as parameter /led_frequency . Create .launch file for Action Server.","title":"Parameters"},{"location":"introduction/parameters/#parameters","text":"Parameter server: globally available dictionary within ROS master ROS parameter: one variable within the parameter server Types: Boolean Int Double String Lists ...","title":"Parameters"},{"location":"introduction/parameters/#example","text":"Code examples: 1 2 3 4 5 6 7 8 9 10 11 # set parameter rospy . set_param ( '/publish_frequency' , 2 ) # get parameter publish_freq = rospy . get_param ( '/publish_frequency' ) # get list of parameters try : rospy . get_param_names () except ROSException : print ( \"Could not get param names\" ) Set parameter in a launch file: <param name= \"/parameter_name\" type= \"parameter_type\" value= \"value\" /> 1 2 3 <launch> <param name= \"/publish_frequency\" type= \"int\" value= \"2\" /> </launch> <rosparam> is used if you want to load a list of parameters from a .yaml file 1 <rosparam command= \"load\" file= \"$(find <package_name>)/example.yaml\" />","title":"Example"},{"location":"introduction/parameters/#debug","text":"rosparam set <param name> <value> - to create new parameter rosparam get <param name> - get parameter value rosparam list - get list of parameters","title":"DEBUG"},{"location":"introduction/parameters/#exercise","text":"Upgrade SimpleActionClient by setting number of runs as parameter /number_of_runs . Upgrade SimpleActionServer by setting LED frequency as parameter /led_frequency . Create .launch file for Action Server.","title":"Exercise"},{"location":"introduction/services/","text":"Services Server/client system Synchronous operation For calculation and quick actions One message type for Request, another message type for Response A server is only one that can respond to multiple clients Example Turn on LED on button press using interrupts. Server Syntax for service server: service = rospy . Service ( '/service_name' , msg_type , handle_fcn ) Example code: led_service_server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/usr/bin/env python import rospy from std_srvs.srv import SetBool import RPi.GPIO as GPIO class ledServer (): def __init__ ( self ): # init variables self . LED_GPIO = 2 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define service # rospy.Service('service_name',varType,callback) rospy . Service ( '/set_led_state' , SetBool , self . set_led_status_callback ) rospy . loginfo ( \"Service server started. Ready to get request.\" ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def set_led_status_callback ( self , req ): # code that is executed when request is received # set LED to req.data GPIO . output ( self . LED_GPIO , req . data ) # server response return { 'success' : True , 'message' : 'Successfully changed LED state.' } def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'led_actuator' ) # initialise class led_server = ledServer () # reset leds led_server . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros led_service_server.py and check the list of services (look for /set_led_state ) rosservice list Use rosservice call to test the server rosservice call /set_led_state \"data: True\" rosservice call /set_led_state \"data: False\" Client Syntax for service proxy (client): 1 2 3 4 5 6 7 rospy . wait_for_service ( '/service_name' ) try : client = rospy . ServiceProxy ( '/service_name' , msg_type ) ... except rospy . ServiceException as e : rospy . logwarn ( 'Service failed' + str ( e )) Example: button_service_client.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python import rospy from std_srvs.srv import SetBool import RPi.GPIO as GPIO class buttonClient (): def __init__ ( self ): # init variables self . BUTTON_GPIO = 11 self . LED_STATE = False # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set button GPIO as input GPIO . setup ( self . BUTTON_GPIO , GPIO . IN ) # set interrupt # GPIO.add_event_detect(gpio_num, edge, callback, bouncetime) GPIO . add_event_detect ( self . BUTTON_GPIO , GPIO . RISING , callback = self . button_callback , bouncetime = 500 ) # define service proxy # rospy.ServiceProxy('service_name', varType) # wait for service rospy . wait_for_service ( '/set_led_state' ) # define proxy self . set_led_state = rospy . ServiceProxy ( '/set_led_state' , SetBool ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def button_callback ( self , channel ): # code that is called from interrupt # get the button state power_on_led = GPIO . input ( self . BUTTON_GPIO ) # change LED state self . LED_STATE = not self . LED_STATE try : # send request, get response resp = self . set_led_state ( self . LED_STATE ) # print response print ( resp ) except rospy . ServiceException as e : # in case of error rospy . logwarn ( e ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'button_monitor' ) # initialise class button_client = buttonClient () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test, run both server and client in seperate terminals rosrun rpi_feros led_service_server.py rosrun rpi_feros button_service_client.py With a button press, LED should turn on and off. DEBUG rosservice list - list of all active services rosservice info <service name> - information about the selected service rosservice call <service name> - request to service server from the console Exercise Use buttons to shift active LED left or right.","title":"Service"},{"location":"introduction/services/#services","text":"Server/client system Synchronous operation For calculation and quick actions One message type for Request, another message type for Response A server is only one that can respond to multiple clients","title":"Services"},{"location":"introduction/services/#example","text":"Turn on LED on button press using interrupts.","title":"Example"},{"location":"introduction/services/#server","text":"Syntax for service server: service = rospy . Service ( '/service_name' , msg_type , handle_fcn ) Example code: led_service_server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/usr/bin/env python import rospy from std_srvs.srv import SetBool import RPi.GPIO as GPIO class ledServer (): def __init__ ( self ): # init variables self . LED_GPIO = 2 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define service # rospy.Service('service_name',varType,callback) rospy . Service ( '/set_led_state' , SetBool , self . set_led_status_callback ) rospy . loginfo ( \"Service server started. Ready to get request.\" ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def set_led_status_callback ( self , req ): # code that is executed when request is received # set LED to req.data GPIO . output ( self . LED_GPIO , req . data ) # server response return { 'success' : True , 'message' : 'Successfully changed LED state.' } def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'led_actuator' ) # initialise class led_server = ledServer () # reset leds led_server . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros led_service_server.py and check the list of services (look for /set_led_state ) rosservice list Use rosservice call to test the server rosservice call /set_led_state \"data: True\" rosservice call /set_led_state \"data: False\"","title":"Server"},{"location":"introduction/services/#client","text":"Syntax for service proxy (client): 1 2 3 4 5 6 7 rospy . wait_for_service ( '/service_name' ) try : client = rospy . ServiceProxy ( '/service_name' , msg_type ) ... except rospy . ServiceException as e : rospy . logwarn ( 'Service failed' + str ( e )) Example: button_service_client.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python import rospy from std_srvs.srv import SetBool import RPi.GPIO as GPIO class buttonClient (): def __init__ ( self ): # init variables self . BUTTON_GPIO = 11 self . LED_STATE = False # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set button GPIO as input GPIO . setup ( self . BUTTON_GPIO , GPIO . IN ) # set interrupt # GPIO.add_event_detect(gpio_num, edge, callback, bouncetime) GPIO . add_event_detect ( self . BUTTON_GPIO , GPIO . RISING , callback = self . button_callback , bouncetime = 500 ) # define service proxy # rospy.ServiceProxy('service_name', varType) # wait for service rospy . wait_for_service ( '/set_led_state' ) # define proxy self . set_led_state = rospy . ServiceProxy ( '/set_led_state' , SetBool ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def button_callback ( self , channel ): # code that is called from interrupt # get the button state power_on_led = GPIO . input ( self . BUTTON_GPIO ) # change LED state self . LED_STATE = not self . LED_STATE try : # send request, get response resp = self . set_led_state ( self . LED_STATE ) # print response print ( resp ) except rospy . ServiceException as e : # in case of error rospy . logwarn ( e ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'button_monitor' ) # initialise class button_client = buttonClient () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test, run both server and client in seperate terminals rosrun rpi_feros led_service_server.py rosrun rpi_feros button_service_client.py With a button press, LED should turn on and off.","title":"Client"},{"location":"introduction/services/#debug","text":"rosservice list - list of all active services rosservice info <service name> - information about the selected service rosservice call <service name> - request to service server from the console","title":"DEBUG"},{"location":"introduction/services/#exercise","text":"Use buttons to shift active LED left or right.","title":"Exercise"},{"location":"introduction/setup/","text":"ROS setup roscore takes care of communicaiton between different ROS functionalities it can run only one at once connects different ROS system into one ROS network roscore catkin workspace CATKIN is an official build system for ROS cd mkdir catkin_ws cd catkin_ws mkdir src catkin_make Alternative is to use catkin build (beforehand you need to remove devel and build folders). Conect console with ROS variables cd devel source setup.bash To do this automatically when the console is opened, add to bashrc.sh echo \"source ~/catkin_ws/devel/setup.bash\" >> ~/.bashrc source ~/.bashrc","title":"ROS setup"},{"location":"introduction/setup/#ros-setup","text":"","title":"ROS setup"},{"location":"introduction/setup/#roscore","text":"takes care of communicaiton between different ROS functionalities it can run only one at once connects different ROS system into one ROS network roscore","title":"roscore"},{"location":"introduction/setup/#catkin-workspace","text":"CATKIN is an official build system for ROS cd mkdir catkin_ws cd catkin_ws mkdir src catkin_make Alternative is to use catkin build (beforehand you need to remove devel and build folders). Conect console with ROS variables cd devel source setup.bash To do this automatically when the console is opened, add to bashrc.sh echo \"source ~/catkin_ws/devel/setup.bash\" >> ~/.bashrc source ~/.bashrc","title":"catkin workspace"},{"location":"introduction/topics/","text":"Topics Topic is: a communication channel through which nodes exchange messages one-way messaging (publisher> subscriber) anonymous topic has its own message type ( list of standars message types ) ROS master takes care of the proper publisher/subscriber connection each node can have multiple publishers/subscribers for different topics Example Turn on LED on button press. Publisher Syntax for publisher: pub = rospy . Publisher ( '/topic_name' , msg_type , queue_size = 10 ) Example code: button_publisher.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #!/usr/bin/env python import rospy import RPi.GPIO as GPIO from std_msgs.msg import Bool # buttons GPIO pins # button 1 - gpio 11 # button 2 - gpio 12 class rpi_button (): def __init__ ( self ): # init variables self . BUTTON_GPIO = 11 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set button IO as input GPIO . setup ( self . BUTTON_GPIO , GPIO . IN ) # set loop frequency to 10 Hz self . rate = rospy . Rate ( 10 ) # define publisher # rospy.Publisher(\"topic_name\", varType, queue_size) self . pub = rospy . Publisher ( '/button_state' , Bool , queue_size = 10 ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def read_button ( self ): while not self . ctrl_c : # read GPIO pin gpio_state = GPIO . input ( self . BUTTON_GPIO ) # define msg as Bool variable self . msg = Bool () # msg has a data \"data\" self . msg . data = gpio_state # send msg self . publish_once () def publish_once ( self ): \"\"\" This is because publishing in topics sometimes fails the first time you publish. In continuous publishing systems, this is no big deal, but in systems that publish only once, it IS very important. \"\"\" while not self . ctrl_c : connections = self . pub . get_num_connections () if connections > 0 : self . pub . publish ( self . msg ) #rospy.loginfo(\"Msg Published\") break else : self . rate . sleep () def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all GPIO settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'button_state_publisher' , anonymous = True ) # initialise class btn = rpi_button () try : btn . read_button () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros button_publisher.py check the list of topics (look for /button_state ) rostopic list Then listen to that topic rostopic echo /button_state -c and press the button on RaspberryPi. Subscriber Syntax for subscriber: sub = rospy . Subscriber ( '/topic_name' , msg_type , callback_fcn ) Example code: led_actuator.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #!/usr/bin/env python import rospy from std_msgs.msg import Bool import RPi.GPIO as GPIO # GPIO za LED: # Green 1 - GPIO 2 # Green 2 - GPIO 3 # Yellow 1 - GPIO 4 # Yellow 2 - GPIO 5 # Red 1 - GPIO 6 # Red 2 - GPIO 7 class rpi_led (): def __init__ ( self ): # init variables self . LED_GPIO = 7 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define subscriber # rospy.Subscriber('topic_name', varType, callback) self . sub = rospy . Subscriber ( '/button_state' , Bool , self . button_state_callback ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def button_state_callback ( self , msg ): # the code that is executed when data is received # turn on LED GPIO . output ( self . LED_GPIO , msg . data ) def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'led_actuator' ) # initialise class led_act = rpi_led () # reset leds led_act . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros led_actuator.py After that check topics (loook for /button_state ): rostopic list Use rostopic pub to turn LED on and off: rostopic pub /button_state std_msgs/Bool \"data: True\" rostopic pub /button_state std_msgs/Bool \"data: False\" To test both (publisher and subscriber), run each in the invidual terminal: rosrun rpi_feros button_publisher.py and rosrun rpi_feros led_actuator.py When pressing the button on RPi, the LED should turn on. DEBUG rostopic -h - rostopic help rostopic list - list of all active topics rostopic echo <topic name> - listen to selected topic -c - clear output each time -n2 - print only 2 outputs rostopic info <topic name> - information about topic rostopic pub <topic name> + Tab for autocomplete - publish data -1 - publish only once -r5 - publish with 5 Hz Exercise Turn on LED if the object is closer than 0.2 m.","title":"Topics"},{"location":"introduction/topics/#topics","text":"Topic is: a communication channel through which nodes exchange messages one-way messaging (publisher> subscriber) anonymous topic has its own message type ( list of standars message types ) ROS master takes care of the proper publisher/subscriber connection each node can have multiple publishers/subscribers for different topics","title":"Topics"},{"location":"introduction/topics/#example","text":"Turn on LED on button press.","title":"Example"},{"location":"introduction/topics/#publisher","text":"Syntax for publisher: pub = rospy . Publisher ( '/topic_name' , msg_type , queue_size = 10 ) Example code: button_publisher.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #!/usr/bin/env python import rospy import RPi.GPIO as GPIO from std_msgs.msg import Bool # buttons GPIO pins # button 1 - gpio 11 # button 2 - gpio 12 class rpi_button (): def __init__ ( self ): # init variables self . BUTTON_GPIO = 11 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set button IO as input GPIO . setup ( self . BUTTON_GPIO , GPIO . IN ) # set loop frequency to 10 Hz self . rate = rospy . Rate ( 10 ) # define publisher # rospy.Publisher(\"topic_name\", varType, queue_size) self . pub = rospy . Publisher ( '/button_state' , Bool , queue_size = 10 ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def read_button ( self ): while not self . ctrl_c : # read GPIO pin gpio_state = GPIO . input ( self . BUTTON_GPIO ) # define msg as Bool variable self . msg = Bool () # msg has a data \"data\" self . msg . data = gpio_state # send msg self . publish_once () def publish_once ( self ): \"\"\" This is because publishing in topics sometimes fails the first time you publish. In continuous publishing systems, this is no big deal, but in systems that publish only once, it IS very important. \"\"\" while not self . ctrl_c : connections = self . pub . get_num_connections () if connections > 0 : self . pub . publish ( self . msg ) #rospy.loginfo(\"Msg Published\") break else : self . rate . sleep () def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all GPIO settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'button_state_publisher' , anonymous = True ) # initialise class btn = rpi_button () try : btn . read_button () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros button_publisher.py check the list of topics (look for /button_state ) rostopic list Then listen to that topic rostopic echo /button_state -c and press the button on RaspberryPi.","title":"Publisher"},{"location":"introduction/topics/#subscriber","text":"Syntax for subscriber: sub = rospy . Subscriber ( '/topic_name' , msg_type , callback_fcn ) Example code: led_actuator.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #!/usr/bin/env python import rospy from std_msgs.msg import Bool import RPi.GPIO as GPIO # GPIO za LED: # Green 1 - GPIO 2 # Green 2 - GPIO 3 # Yellow 1 - GPIO 4 # Yellow 2 - GPIO 5 # Red 1 - GPIO 6 # Red 2 - GPIO 7 class rpi_led (): def __init__ ( self ): # init variables self . LED_GPIO = 7 # set GPIO kot BCM GPIO . setmode ( GPIO . BCM ) # set all leds for ii in range ( 2 , 8 ): # set IO as outputs GPIO . setup ( ii , GPIO . OUT ) # define subscriber # rospy.Subscriber('topic_name', varType, callback) self . sub = rospy . Subscriber ( '/button_state' , Bool , self . button_state_callback ) self . ctrl_c = False rospy . on_shutdown ( self . shutdownhook ) def button_state_callback ( self , msg ): # the code that is executed when data is received # turn on LED GPIO . output ( self . LED_GPIO , msg . data ) def resetLed ( self ): # reset all leds for ii in range ( 2 , 8 ): # turn off all leds GPIO . output ( ii , False ) def shutdownhook ( self ): # works better than the rospy.is_shutdown() # this code is run at ctrl + c # clear all settings GPIO . cleanup () self . ctrl_c = True if __name__ == '__main__' : # initialise node rospy . init_node ( 'led_actuator' ) # initialise class led_act = rpi_led () # reset leds led_act . resetLed () try : # loop rospy . spin () except rospy . ROSInterruptException : pass To test the code run rosrun rpi_feros led_actuator.py After that check topics (loook for /button_state ): rostopic list Use rostopic pub to turn LED on and off: rostopic pub /button_state std_msgs/Bool \"data: True\" rostopic pub /button_state std_msgs/Bool \"data: False\" To test both (publisher and subscriber), run each in the invidual terminal: rosrun rpi_feros button_publisher.py and rosrun rpi_feros led_actuator.py When pressing the button on RPi, the LED should turn on.","title":"Subscriber"},{"location":"introduction/topics/#debug","text":"rostopic -h - rostopic help rostopic list - list of all active topics rostopic echo <topic name> - listen to selected topic -c - clear output each time -n2 - print only 2 outputs rostopic info <topic name> - information about topic rostopic pub <topic name> + Tab for autocomplete - publish data -1 - publish only once -r5 - publish with 5 Hz","title":"DEBUG"},{"location":"introduction/topics/#exercise","text":"Turn on LED if the object is closer than 0.2 m.","title":"Exercise"},{"location":"kamera/logitech_C920/","text":"Aruco with Logitech C922 Logitech C922 1080p @ 30 fps 720p @ 60 fps 3 Mpx diagonal field of view 78\u00b0 autofocus usb_cam driver First, a camera driver needs to be installed - wiki sudo apt-get install ros-melodic-usb-cam Check for camera device ( ls /dev , look for new videoX ) and run the driver ( /dev/video3 replace with the correct device): rosrun usb_cam usb_cam_node _camera_name: = 'usb_cam' _camera_frame_id: = 'usb_cam' _video_device: = '/dev/video3' _image_width: = 1920 _image_height: = 1080 You can check the video stream in RViz (Add > By topic > /usb_cam/image_raw/image). Calibration With this procedure, the camera's intrinsic parameters are obtained. Install camera_calibration package - wiki sudo apt install ros-melodic-camera-calibration Prepare the calibration checkerboard - example can be found here: checkerboard, 12x16 fields, square side 15 mm Run calibration node rosrun camera_calibration cameracalibrator.py --size 11x15 --square 0 .015 image: = /usb_cam/image_raw camera: = /usb_cam Move the calibration checkerboard on the plane you want to calibrate until \"Calibrate\" button is active. After calibration procedure is finished commit calibration with the buttons \"Save\" and \"Commit\". Aruco markers Aruco markers are used to determine the pose of an object equipped with proper markers. For this fiducials and aruco_detect packages are used. Install packages: sudo apt-get install ros-melodic-fiducials sudo apt-get install ros-melodic-aruco-detect Generate markers (14 cm side; for anything else, tune the .py file): rosrun aruco_detect create_markers.py 100 110 fiducials.pdf Use the aruco_detect package to detect aruco markers. Set the correct parameters for the camera. roslaunch aruco_detect aruco_detect.launch camera: = /usb_cam image: = image_raw fiducial_len: = 0 .14 When using Intel RealSense D435i run roslaunch aruco_detect aruco_detect.launch camera: = /camera/color fiducial_len: = 0 .14 Change fiducial_len to the size of markers used. Pose of the marker is returned in the /fiducial_transforms topic. Markers can also be seen with roslaunch fiducial_slam fiducial_rviz.launch","title":"Aruco markers"},{"location":"kamera/logitech_C920/#aruco-with-logitech-c922","text":"Logitech C922 1080p @ 30 fps 720p @ 60 fps 3 Mpx diagonal field of view 78\u00b0 autofocus","title":"Aruco with Logitech C922"},{"location":"kamera/logitech_C920/#usb_cam-driver","text":"First, a camera driver needs to be installed - wiki sudo apt-get install ros-melodic-usb-cam Check for camera device ( ls /dev , look for new videoX ) and run the driver ( /dev/video3 replace with the correct device): rosrun usb_cam usb_cam_node _camera_name: = 'usb_cam' _camera_frame_id: = 'usb_cam' _video_device: = '/dev/video3' _image_width: = 1920 _image_height: = 1080 You can check the video stream in RViz (Add > By topic > /usb_cam/image_raw/image).","title":"usb_cam driver"},{"location":"kamera/logitech_C920/#calibration","text":"With this procedure, the camera's intrinsic parameters are obtained. Install camera_calibration package - wiki sudo apt install ros-melodic-camera-calibration Prepare the calibration checkerboard - example can be found here: checkerboard, 12x16 fields, square side 15 mm Run calibration node rosrun camera_calibration cameracalibrator.py --size 11x15 --square 0 .015 image: = /usb_cam/image_raw camera: = /usb_cam Move the calibration checkerboard on the plane you want to calibrate until \"Calibrate\" button is active. After calibration procedure is finished commit calibration with the buttons \"Save\" and \"Commit\".","title":"Calibration"},{"location":"kamera/logitech_C920/#aruco-markers","text":"Aruco markers are used to determine the pose of an object equipped with proper markers. For this fiducials and aruco_detect packages are used. Install packages: sudo apt-get install ros-melodic-fiducials sudo apt-get install ros-melodic-aruco-detect Generate markers (14 cm side; for anything else, tune the .py file): rosrun aruco_detect create_markers.py 100 110 fiducials.pdf Use the aruco_detect package to detect aruco markers. Set the correct parameters for the camera. roslaunch aruco_detect aruco_detect.launch camera: = /usb_cam image: = image_raw fiducial_len: = 0 .14 When using Intel RealSense D435i run roslaunch aruco_detect aruco_detect.launch camera: = /camera/color fiducial_len: = 0 .14 Change fiducial_len to the size of markers used. Pose of the marker is returned in the /fiducial_transforms topic. Markers can also be seen with roslaunch fiducial_slam fiducial_rviz.launch","title":"Aruco markers"}]}